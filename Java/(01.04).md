# 1. Методы класса Exception

- `toString()` – название класса и текст ошибки;
- `getMessage()` – текст ошибки;
- `getStackTrace()` – возвращает массив, содержащий трассировку стека исключения;
- `printStackTrace()` – отображает трассировку стека.

```java
public class Main {
	public static void main(String[] args) {
		try {
		int a = 100 / 0;
		}
		catch(Exception ex) {
			System.out.println(ex.getMessage()); // "/ by zero"
			System.out.println(ex.printStackTrace()); // "/ by zero"
		}
	}
}
```

---
# 2. Функциональное программирование

>[!Note] Понятие 
>**Функциональный интерфейс** – интерфейс, содержащий единственный абстрактный метод (single abstract method).
>- Может быть аннотирован как **@FunctionalInterface**.


```java
@FunctionalInterface
public interface MyInterface {
	public double f();
}

MyInterface myInt = new MyInterface() {
	@Override
	public double f() {
		return 3.1415926;
	}
};

System.out.println(myInt.f());		
```

```java
public class Main {
	@FunctionalInterface
	interface MyInterface {
		public double f(int a, int b);
	}
	
	public static void main(String[] args) {
		MyInterface myInt = new MyInterface() {
			@Override
			public double f(int a, int b) {
				return a * b;
			}
		};

		System.out.println(myInt.f(4, 5));
	}
}
```

---
# 3. Лямбда-выражения

<center>([parameter]) -> lambda body</center>


| **Однострочные:**                               | **Блочные:**                                             |
| ----------------------------------------------- | -------------------------------------------------------- |
| () -> System.out.println("Lambdas are great!"); | () -> {<br>    double pi = 3.14;<br>    return pi;<br>}; |

```java
public class Main {
	public static void main(String[] args) {
		MyInterface myInt = (a,b) -> a * b;

		System.out.println(myInt.f(4, 5));
	}
}
```

---
# 4. Ещё о ФИ

**Стандартные интерфейсы:**
- Runnable: SAM – run(): _используется при создании многопоточных приложений_;
- Comparator: SAM – compare().


---
# 5. Параметризированный функциональный интерфейс

```java
@FunctionalInterface
public interface MyInterface<T>{
	public T f(T t);
}
```
**Стандартные интерфейс:** `Predicate<T>`: SAM – test(T t);

```java
import java.util.function.Predicate;

public class Main {
	static void f(List<Integer> list, Predicate<Integer> pr) {
		for (Integer n:list)
			if (pr.test(n))
				System.out.println(n);
	}
	
	public static void main(String[] args) {
		List<Integer> list = Arrays.asList(1,2,3,4,5,6,7,8);
		
		f(list, (n) -> n % 2 == 0);
 	}
}
```

---
# 6. Ссылки на методы

> Если лямбда-выражения вызывают только один существующий метод, то лучше ссылаться на этот метод по его имени. Ссылки на методы (Method References) – это компактные лямбда-выражения для методов, у которых уже есть имя.
> 1. object::instanceMethod: `System.out::println равно x : System.out.println(x);`
> 2. Class::staticMethod: `Math::max равно (x,y) : Math.max(x, y);`
> 3. : `String::length ... : Math.max(x, y);`

```java
import java.util.function.Predicate;

public class Main {
	static void f(List<Integer> list) {
		list.forEach(System.out::println); // == list.forEach((n) -> System.out.println(n));
	}
	
	public static void main(String[] args) {
		List<Integer> list = Arrays.asList(1,2,3,4,5,6,7,8);
		
		f(list);
 	}
}
```

---
# 7. Stream API (java.util.stream)

> Коллекции обеспеч эфффект доступ к одиноч объектам, а стримы, наоборот, для прямого доступа и обработки отд элтов не исопльзуются. Стримы предназнач для паралл и послед агрегаций, выполн через цепочку методов.

- Поток однотип данных для однотип обработки;
- Промеж операции описывают 
- 3
- 4

Промежуточные операции: peek(), limit(), skip()...
В конце цепочки промежуточных операций должна стоять терминальная: collect(), forEach(), count(), min(), max(), findFirst(), findAny() - _любой подходящий элемент_, allMatch(), noneMatch(), anyMatch() - _хотя бы один подходящий элемент_, sum(), reduce(), get().

```java
IntStream.of(120,410,85, 32, 32, 314, 12)
	.filter(x -> x < 300)
	.map(x -> x + 11)
	.limit(3)
	.forEach(System.out::println);
>>> 131
>>> 96
>>> 43
```
