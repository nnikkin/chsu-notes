## __Программа, комплекс программ, программное средство, программное обеспечение, программный продукт. Концепция программного изделия: непосредственная производительная сила, промышленная технология проектирования программ, стандарты и сборочное программирование, контроль и управление качеством программ, экономика программных средств, подготовка специалистов по всем этапам жизненного цикла программ, разделение труда специалистов в проектных организациях.__

__Программа__ — упорядоченная последовательность команд (инструкций) компьютера или операторов для решения задачи.
__Комплекс программ__ — это набор взаимосвязанных программ для решения определённой проблемы (или задачи).
__Программное средство__ — это объект, состоящий из программ, процедур, правил и сопутствующих им документации и данных.
__Программное обеспечение__ — это совокупность программ системы обработки информации и программных документов, необходимых для эксплуатации этих программ
__Программный продукт (или программное изделие)__ — это комплекс взаимосвязанных программ для решения определенной проблемы (задачи) массового спроса, подготовленный к реализации как любой вид промышленной продукции. _Программная
продукция_ — это программа (программный комплекс, программная система),
которую стремятся продать на широком рынке тысячам, миллионам пользователей.

### Концепция программного изделия
Программное изделие (или программный продукт) — это результат промышленного подхода к разработке программного обеспечения. Этот подход рассматривает ПО не как результат творчества одного разработчика, а как продукт, созданный по чётким инженерным и экономическим правилам.
#### **Непосредственная производительная сила**
__Непосредственная производительная сила__ — это научные и технические знания, которые непосредственно внедряются в производство и активно используются в нем для создания материальных благ.
В современной экономике программное обеспечение перестало быть просто вспомогательным инструментом. Оно стало **прямой производительной силой**, то есть средством производства, которое непосредственно участвует в создании товаров и услуг. Автоматизация производства, логистики, финансов, аналитики — всё это примеры того, как ПО напрямую увеличивает производительность и создаёт стоимость.
#### **Промышленная технология проектирования программ**
Это переход от "кустарного" написания кода к фабричному производству. Промышленный подход включает:
- **Методологии разработки**: Использование строгих моделей, таких как Waterfall (Водопадная), Agile, Scrum, для организации процесса.
- **Автоматизация**: Применение инструментов для автоматической сборки, тестирования (CI/CD) и развёртывания программ.
- **Моделирование**: Использование языков вроде UML для проектирования архитектуры системы перед написанием кода.
#### **Стандарты и сборочное программирование**
Чтобы создавать большие и сложные системы, нужны общие правила и готовые блоки.
- **Стандарты**: Это набор правил и соглашений (например, стандарты кодирования, протоколы обмена данными вроде HTTP, стандарты безопасности), которые обеспечивают совместимость и предсказуемость.
- **Сборочное программирование**: Концепция, при которой программа не пишется с нуля, а собирается из уже существующих, проверенных компонентов, библиотек и фреймворков. Это значительно ускоряет разработку и повышает надёжность.
#### **Контроль и управление качеством программ (QA)**
Качество продукта — ключевой фактор его успеха. В промышленной разработке это не случайность, а результат целенаправленной деятельности, включающей:
- **Тестирование**: Проверка продукта на ошибки (баги) на разных уровнях (модульное, интеграционное, системное).
- **Анализ кода (Code Review)**: Проверка кода другими разработчиками для поиска ошибок и улучшения его качества.
- **Метрики качества**: Использование показателей (например, количество дефектов на тысячу строк кода) для оценки и контроля качества.
#### **Экономика программных средств**
Программный продукт — это экономический актив. Его разработка требует инвестиций, а результат должен приносить прибыль. Экономика ПО включает:
- **Оценку трудозатрат и бюджета**: Планирование ресурсов, необходимых для создания продукта.
- **Ценообразование**: Определение стоимости продукта на основе затрат, ценности для клиента и рыночной конъюнктуры (например, продажа лицензий, подписка).
- **Совокупная стоимость владения (TCO)**: Учёт не только стоимости разработки, но и затрат на поддержку, обновления и сопровождение продукта в течение его жизненного цикла.
#### **Подготовка специалистов по всем этапам жизненного цикла**
Промышленное производство ПО требует команды профессионалов с разными навыками, которые покрывают весь **жизненный цикл программы**: от идеи до вывода из эксплуатации. Это аналитики, архитекторы, разработчики, тестировщики, DevOps-инженеры, менеджеры проектов, специалисты по поддержке. Система образования и корпоративного обучения должна готовить кадры для каждой из этих ролей.
#### **Разделение труда специалистов**
Как и на любом заводе, в крупных проектах по разработке ПО существует чёткое разделение труда. Каждый специалист фокусируется на своей области:
- **Бизнес-аналитик** определяет, _что_ нужно сделать.
- **Системный архитектор** решает, _как_ это будет спроектировано в целом.
- **Разработчик (программист)** пишет код, реализуя конкретные функции.
- **Тестировщик (QA-инженер)** проверяет, _правильно ли_ всё работает.
- **Менеджер проекта** следит за сроками, бюджетом и командой.

---

## __Технология программирования, основные этапы развития: «стихийное» программирование, структурное программирование, объектно-ориентированное программирование, компонентное программирование.__

__Технологией программирования__ — это (1) совокупность методов и средств, используемых в процессе разработки программного обеспечения, или (2) система методов, способов и приемов разработки и отладки программ.

___В широком смысле следует понимать технологию разработки программного средства, как совокупность абсолютно всех технологических процессов его создания – от момента зарождения идеи о данном программном средстве (ПС) до составления необходимой программной документации.___

Как любая другая технология, технология программирования представляет собой набор технологических инструкций, включающих:
- указание последовательности выполнения технологических операций;
- перечисление условий, при которых выполняется та или иная операция;
- описания самих операций, где для каждой операции определены исходные данные, результаты, а также инструкции, нормативы, стандарты, критерии, методы оценки и т. п.

### Стихийное программирование (до 60-х гг. XX в.)
До середины 1960-х гг. преимущественно использовалась неструктурированная, «стихийная» технология программирования. Структура первых простейших программ состояла собственно из программы, написанной на машинном языке (в двоичных или шестнадцатеричных кодах) и обрабатываемых ею данных.
Появление машинно-ориентированных языков (ассемблеров) позволило программистам вместо кодов использовать мнемонические обозначения кодов операций и символические имена данных. Программы стали «читаемыми».
Появление языков программирования высокою уровня (FORTRAN, ALGOL) позволило снизить уровень детализации операций. Большим достижением этих языков стала возможность использования подпрограмм. Были созданы большие библиотеки различных подпрограмм. Теперь структура программы состояла из основной программы, области глобальных данных и набора подпрограмм. Недостаток такой структуры — возрастание вероятности искажения части глобальных данных какой-либо подпрограммой при увеличении количества подпрограмм. Для сокращения таких ошибок было предложено размещать в подпрограммах локальные данные. Появилась возможность совместной разработки ПО несколькими программистами.
Использовался метод программирования «снизу—вверх», т.е. сначала разрабатывались простые подпрограммы, а затем строилась сложная программа путем их сборки. При сборке программы появлялось большое количество ошибок согласования, а при их исправлении появлялись новые ошибки. Процесс тестирования и отладки занимал 80% времени разработки ПО.
### Структурное программирование (1960—1970-е гг.)
_Структурный подход к программированию_ представляет собой совокупность рекомендуемых технологических приемов, охватывающих выполнение всех этапов разработки программного обеспечения. В основе структурного подхода лежит Декомпозиция (разбиение на части) сложных систем с целью последующей реализации в виде отдельных небольших (до 40 - 50 операторов) подпрограмм. С появлением других принципов декомпозиции (объектного, логического и т.д.) данный способ получил название _процедурной декомпозиции_.
Э. Дейкстра предложил строить программу как композицию из нескольких типов управляющих конструкций (структур), которые позволяют повысить понимаемость логики работы программы. Программирование с использованием только таких конструкций назвали __структурным__.
В отличие от используемого ранее процедурного подхода к декомпозиции, структурный
подход требовал представления задачи в виде иерархии подзадач простейшей структуры.
Проектирование, таким образом, осуществлялось «сверху вниз» и подразумевало реализацию общей идеи, обеспечивая проработку интерфейсов подпрограмм. Одновременно вводились ограничения на конструкции алгоритмов, рекомендовались формальные модели их описания, а также специальный метод проектирования алгоритмов - метод пошаговой детализации.
__Основными конструкциями структурного программирования являются__:
- следование (выполнение операторов последовательно),
- разветвление (в зависимости от выполнения некоторого условия выполняется та или иная последовательность операторов),
- повторение (многократное выполнение одинаковой последовательности операторов).
Спецификации процессов могут быть представлены в виде псевдокодов, блок-схем алгоритмов, Flow-форм, диаграмм Насси – Шнейдермана или просто краткого текстового описания. Наибольшую популярность получили схемы алгоритмов. Для изображения схем алгоритмов разработан ГОСТ 19.701–90.
Дальнейший рост сложности и размеров разрабатываемого программного обеспечения потребовал развития структурирования Данных. Как следствие этого в языках появляется возможность определения пользовательских типов данных. Одновременно усилилось стремление разграничить доступ к глобальным данным программы, чтобы уменьшить количество ошибок, возникающих при работе с глобальными данными. В результате появилась и начала развиваться технология модульного программирования.
Модульное программирование предполагает выделение групп подпрограмм, использующих одни и те же глобальные данные в отдельно компилируемые модули (библиотеки подпрограмм), например, модуль графических ресурсов, модуль подпрограмм вывода на принтер (рис. 1.5). между модулями при использовании данной технологии осуществляются через специальный интерфейс, в то время как доступ к реализации модуля (телам подпрограмм и некоторым «внутренним» переменным) запрещен. Эту технологию поддерживают современные языков Pascal и С (С-4+), языки Ада и Modula.
### Объектно-ориентированное программирование (сер. 80-х — сер. 90-х гг.)
**Объектно-ориентированное программирование** определяется как технология создания сложного программного обеспечения, основанная на представлении программы в виде совокупности **объектов**, каждый из которых является экземпляром определенного типа          (**класса**), а классы образуют иерархию с **наследованием** свойств. Взаимодействие программных объектов в такой системе осуществляется путем передачи **сообщений**.
Объектная структура программы впервые была использована в языке имитационного моделирования сложных систем Simula, появившемся еще в 60-х годах XX в. Естественный для языков моделирования способ представления программы получил развитие в другом специализированном языке моделирования - языке Smalltalk (70-е годы XX в.), а затем был использован в новых версиях универсальных языков программирования, таких, как Pascal, C++, Modula, Java.  
Основным достоинством объектно-ориентированного программирования по сравнению с модульным программированием является «более естественная» декомпозиция программного обеспечения, которая существенно облегчает его разработку. Это приводит к более полной локализации данных и интегрированию их с подпрограммами обработки, что позволяет вести практически независимую разработку отдельных частей (объектов) программы. Кроме этого, объектный подход предлагает новые способы организации программ, основанные на механизмах наследования, полиморфизма, композиции, наполнения. Эти механизмы позволяют конструировать сложные объекты из сравнительно простых. В результате существенно увеличивается показатель повторного использования кодов и появляется возможность создания библиотек классов для различных применений.  
Бурное развитие технологий программирования, основанных на объектном подходе, позволило решить многие проблемы. Так были созданы среды, поддерживающие **визуальное программирование**, например, Delphi, C++ Builder, Visual C++ и т. д. При использовании визуальной среды у программиста появляется возможность проектировать некоторую часть, например, интерфейсы будущего продукта, с применением визуальных средств добавления и настройки специальных библиотечных компонентов. Результатом визуального проектирования является заготовка будущей программы, в которую уже внесены соответствующие коды.  
Использование объектного подхода имеет много преимуществ, однако его конкретная реализация в объектно-ориентированных языках программирования, таких, как Pascal и C++, имеет существенные недостатки:
- фактически отсутствуют стандарты компоновки двоичных результатов компиляции объектов в единое целое даже в пределах одного языка программирования: компоновка объектов, полученных разными компиляторами C++ в лучшем случае проблематична, что приводит к необходимости разработки программного обеспечения с использованием средств и возможностей одного языка программирования высокого уровня и одного компилятора, а значит, требует одного языка программирования высокого уровня и одного компилятора, а значит, требует наличия исходных кодов используемых библиотек классов;
- изменение реализации одного из программных объектов, как минимум, связано с перекомпиляцией соответствующего модуля и перекомпоновкой всего программного обеспечения, использующего данный объект.

Таким образом, при использовании этих языков программирования сохраняется зависимость модулей программного обеспечения от адресов экспортируемых полей и методов, а также структур и форматов данных. Эта зависимость объективна, так как модули должны взаимодействовать между собой, обращаясь к ресурсам друг друга. Связи модулей нельзя разорвать, но можно попробовать стандартизировать их взаимодействие, на чем и основан компонентный подход к программированию.

### Компонентный подход и CASE-технологии (середина 90-х гг. XX в. — настоящее время)
**Компонентный подход** предполагает построение программного обеспечения из отдельных компонентов физически отдельно существующих частей программного обеспечения, которые взаимодействуют между собой через **стандартизованные двоичные интерфейсы**. В отличие от обычных объектов объекты-компоненты можно собрать в динамически вызываемые библиотеки или исполняемые файлы, распространять в двоичном виде (без исходных текстов) и использовать в любом языке программирования, поддерживающем соответствующую технологию.
Компонентный подход лежит в основе технологий, разработанных на базе **COM** (Component Object Model - компонентная модель объектов), и технологии создания распределенных приложений CORBA (Common Object Request Broker Architecture - общая архитектура с посредником обработки запросов объектов). Эти технологии используют сходные принципы и различаются лишь особенностями их реализации.  
Технология СОМ фирмы Microsoft является развитием технологии OLE I (Object Linking and Embedding - связывание и внедрение объектов), которая использовалась в ранних версиях Windows для создания составных документов. Технология СОМ определяет **общую парадигму взаимодействия программ любых типов**: библиотек, приложений, операционной системы, т. е. позволяет одной части программного обеспечения использовать функции (**службы**), предоставляемые другой, независимо от того, функционируют ли эти части в пределах одного процесса, в разных процессах на одном компьютере или на разных компьютерах. Модификация СОМ, обеспечивающая передачу вызовов между компьютерами, называется DCOM (Distributed COM – распределенная СОМ).
По технологии СОМ приложение предоставляет свои службы, используя специальные объекты - **объекты** СОМ, которые являются экземплярами **классов** СОМ. Объект СОМ так же, как обычный объект включает поля и методы, но в отличие от обычных объектов каждый объект СОМ может реализовывать несколько интерфейсов, обеспечивающих доступ к его полям и функциям. Это достигается за счет организации отдельной таблицы адресов методов для каждого интерфейса (по типу таблиц виртуальных методов). При этом интерфейс обычно объединяет несколько однотипных функций. Кроме того, классы СОМ поддерживают **наследование интерфейсов**, но не поддерживают **наследования реализации**, т. е. не наследуют код методов, хотя при необходимости объект класса-потомка может вызвать метод родителя.  
Каждый интерфейс имеет имя, начинающееся с символа «I» и глобальный уникальный идентификатор IID (Interface IDentifier). Любой объект СОМ обязательно реализует интерфейс IUnknown (на схемах этот интерфейс всегда располагают сверху). Использование этого интерфейса позволяет получить доступ к остальным интерфейсам объекта.  
Объект всегда функционирует в составе сервера - динамической библиотеки или исполняемого файла, которые обеспечивают функционирование объекта. Различают три типа серверов:
- **внутренний сервер** - реализуется динамическими библиотеками, которые подключаются к приложению-клиенту и работают в одном с ними адресном пространстве - наиболее эффективный сервер, кроме того, он не требует специальных средств;
- **локальный сервер** - создается отдельным процессом (модулем, exe), который работает на одном компьютере с клиентом;
- **удаленный сервер** - создается процессом, который работает на другом компьютере.
Например, Microsoft Word является локальным сервером. Он включает множество объектов, которые могут использоваться другими приложениями.  
Для обращения к службам клиент должен получить указатель на соответствующий интерфейс. Перед первым обращением к объекту клиент посылает запрос к библиотеке СОМ, хранящей информацию обо всех, зарегистрированных в системе классах СОМ объектов, и передает ей имя класса, идентификатор интерфейса и тип сервера. Библиотека запускает необходимый сервер, создает требуемые объекты и возвращает указатели на объекты и интерфейсы. Получив указатели, клиент может вызывать необходимые функции объекта.  
Взаимодействие клиента и сервера обеспечивается базовыми механизмами СОМ или DCOM, поэтому клиенту безразлично местонахождение объекта. При использовании локальных и удаленных серверов в адресном пространстве клиента создается **proxy-объект** - заместитель объекта СОМ, а в адресном пространстве сервера СОМ - заглушка, соответствующая клиенту. Получив задание от клиента, заместитель упаковывает его параметры и, используя службы операционной системы, передает вызов заглушке. Заглушка распаковывает задание и передает его объекту СОМ. Результат возвращается клиенту в обратном порядке.  
На базе технологии СОМ и ее распределенной версии DCOM были разработаны компонентные технологии, решающие различные задачи разработки программного обеспечения.  
**OLE-automation** или просто **Automation** (автоматизация) - технология создания программируемых приложений, обеспечивающая программируемый доступ к внутренним службам этих приложений. Вводит понятие **диспинтерфейса** (dispinterface) - специального интерфейса, облегчающего вызов функций объекта. Эту технологию поддерживает, например, Microsoft Excel, предоставляя другим приложениям свои службы.  
**ActiveX** - технология, построенная на базе OLE-automation, предназначена для создания программного обеспечения как сосредоточенного на одном компьютере, так и распределенного в сети. Предполагает использование визуального программирования для создания компонентов - элементов управления ActiveX. Полученные таким образом элементы управления можно устанавливать на компьютер дистанционно с удаленного сервера, причем устанавливаемый код зависит от используемой операционной системы. Это позволяет применять элементы управления ActiveX в клиентских частях приложений Интернет.  
Основными преимуществами технологии ActiveX, обеспечивающими ей широкое распространение, являются:
- быстрое написание программного кода - поскольку все действия, связанные с организацией взаимодействия сервера и клиента берет на программное обеспечение СОМ, программирование сетевых приложений становится похожим на программирование для отдельного компьютера;
- открытость и мобильность - спецификации технологии недавно были переданы в Open Group как основа открытого стандарта;
- возможность написания приложений с использованием знакомых средств разработки, например, Visual Basic, Visual C++, Borland Delphi, Borland C++ и любых средств разработки на Java;
- большое количество уже существующих бесплатных программных элементов ActiveX (к тому же, практически любой программный компонент OLE совместим с технологиями ActiveX и может применяться без модификаций в сетевых приложениях);
- стандартность - технология ActiveX основана на широко используемых стандартах Internet (TCP/IP, HTML, Java), с одной стороны, и стандартах, введенных в свое время Microsoft и необходимых для сохранения совместимости (COM, OLE).

**MTS** (Microsoft Transaction Server - сервер управления транзакциями) - технология, обеспечивающая безопасность и стабильную работу распределенных приложений при больших объемах передаваемых данных.  
**MIDAS** (Multitier Distributed Application Server - сервер многозвенных распределенных приложений) - технология, организующая доступ к данным разных компьютеров с учетом балансировки нагрузки сети.  
Все указанные технологии реализуют компонентный подход, заложенный в СОМ. Так, с точки зрения СОМ элемент управления ActiveX - внутренний сервер, поддерживающий технологию OLE-automation. Для программиста же элемент ActiveX - «черный ящик», обладающий свойствами, методами и событиями, который можно использовать как строительный блок при создании приложений.  
Технология **CORBA**, разработанная группой компаний ОМС (Object Management Group - группа внедрения объектной технологии программирования), реализует подход, аналогичный СОМ, на базе объектов и интерфейсов CORBA. Программное ядро CORBA реализовано для всех основных аппаратных и программных платформ и потому эту технологию можно использовать для создания распределенного программного обеспечения в гетерогенной (разнородной) вычислительной среде. Организация взаимодействия между объектами клиента и сервера в CORBA осуществляется с помощью специального посредника, названного VisiBroker, и другого специализированного программного обеспечения.  
Отличительной особенностью современного этапа развития технологии программирования, кроме изменения подхода, является создание и внедрение автоматизированных технологий разработки и сопровождения программного обеспечения, которые были названы CASE-технологиями (Computer-Aided Software/System Engineering - разработка программного обеспечения/программных систем с использованием компьютерной поддержки). Без средств автоматизации разработка достаточно сложного программного обеспечения на настоящий момент становится трудно осуществимой: память человека уже не в состоянии фиксировать все детали, которые необходимо учитывать при разработке программного обеспечения. На сегодня существуют CASE-технологии, поддерживающие как структурный, так и объектный (в том числе и компонентный) подходы к программированию.  
Появление нового подхода не означает, что отныне все программное обеспечение будет создаваться из программных компонентов, но анализ существующих проблем разработки сложного программного обеспечения показывает, что он будет применяться достаточно широко.

---

## __Программные средства как сложные системы: особенности сложных систем, проблемы определения единого обобщенного критерия эффективности, требования к нему, понятие устойчивости программного средства.__

Программы условно можно разделить на простые и сложные. В начале развития
BRN ЭВМ имели крайне ограниченные, по сравнению с нынешними машинами,
возможности, и их применяли в узких областях науки и техники при решении задач,
условия которых были хорошо детерминированы и формализованы. Такими ЭВМ
управляли простые программные системы. Они, в основном, имеют очень
ограниченную область применения и короткое время жизни. Но с развитием
технологий появились компьютеры и сети, обладающие несравненно большей
вычислительной мощностью. Эго дало возможность создавать сложные программные
системы, которые могут решать ряд важных задач, что даст огромную выгоду, но
также может привести к значительным убыткам при некорректной работе.
Характерная черта таких программных систем — уровень сложности: один
разработчик не в состоянии должным образом охватить все нюансы такой системы.

Большинство современных программных систем объективно очень сложны. Эта сложность обуславливается многими причинами, главной из которых является **логическая сложность решаемых ими задач**.  
Сложность разработки программного обеспечения обусловлена рядом причин:
- сложностью предметной области: пока вычислительных установок было мало, и их возможности были ограничены, ЭВМ применяли в очень узких областях науки и техники, причем, в первую очередь, там, где решаемые задачи были хорошо детерминированы и требовали значительных вычислений. В наше время, когда созданы мощные компьютерные сети, появилась возможность переложить на них решение сложных ресурсоемких задач, о компьютеризации которых раньше никто и не думал. 
- трудностью управления процессом разработки,
- необходимостью обеспечить достаточную гибкость программы,
- неудовлетворительными способами описания поведения больших дискретных систем,
- и т.д.
Дополнительными факторами, увеличивающими сложность разработки программных систем, являются:
- **Cложность формального определения требований к программным системам**: во-первых, при определении требований необходимо учесть большое количество различных факторов. Во-вторых, разработчики программных систем не являются специалистами в автоматизируемых предметных областях, а специалисты в предметной области, как правило, не могут сформулировать проблему в нужном ракурсе.
- **Отсутствие удовлетворительных средств описания поведения дискретных систем с большим числом состояний при недетерминированной последовательности входных воздействий**: в процессе создания программных систем используют языки сравнительно низкого уровня. Это приводит к ранней детализации операций в процессе создания программного обеспечения и увеличивает объем описаний разрабатываемых продуктов, который, как правило, превышает сотни тысяч операторов языка программирования. Средств же позволяющих детально описывать **поведение** сложных дискретных систем на более высоком уровне, чем универсальный язык программирования, не существует.
- **Коллективная разработка**: из-за больших объемов проектов разработка программного обеспечения ведется коллективом специалистов. Работая в коллективе, отдельные специалисты должны взаимодействовать друг с другом, обеспечивая целостность проекта, что при отсутствии удовлетворительных средств описания поведения сложных систем, упоминавшемся выше, достаточно сложно. Причем, чем больше коллектив разработчиков, тем сложнее организовать процесс работы
- **Необходимость увеличения степени повторяемости кодов**: на сложность разрабатываемого программного продукта влияет и то, что для увеличения производительности труда компании стремятся к созданию библиотек компонентов, которые можно было бы использовать в дальнейших разработках. Однако в этом случае компоненты приходится делать более универсальными, что в конечном итоге увеличивает сложность разработки.
Вместе взятые, эти факторы существенно увеличивают сложность процесса разработки. Однако очевидно, что все они напрямую связаны со сложностью объекта разработки - программной системы.
__Устойчивость программного обеспечения__ – свойство осуществлять требуемое преобразование информации при сохранении выходных решений программы в пределах допусков, установленных спецификацией при воздействии на программы таких факторов неустойчивости, как ошибки операторов ЭВМ, а также не выявленных ошибок программы.

---

## __Особенности функционирования сложных программных средств: работа в реальном времени, многообразие функций, надежность функционирования.__

Создание сложных систем с заданными характеристиками при ограниченных ресурсах требует проведения определенного комплекса мероприятий для достижения поставленной цели, который получил название проект. Целенаправленное управление проектом предназначено для пропорционального распределения ресурсов между работами по созданию системы на протяжении всего цикла проектирования вплоть до внедрения системы в серийное производство.
В общем случае при проектировании необходимо создать в соответствии с принятым критерием эффективности оптимальную систему управления или обработки информации при ограничениях двух типов.
- Первый тип ограничений характеризует уровень современных знаний теории и методов решения поставленных задач, принципов построения основных функциональных алгоритмов, методов структурного построения сложных систем и технологии их проектирования.
- Второй тип ограничений относится в основном к техническим параметрам средств, на которых предполагается реализовать сложную систему, и к ресурсам, которые могут быть выделены на разработку и эксплуатацию системы. При проектировании ПС такими техническими ограничениями прежде всего являются параметры ЭВМ (объемы памяти, быстродействие, характеристики обмена информацией и т.д.), на которых предполагается реализовать КП. Важнейшим из ресурсов проектирования являются кадры специалистов соответствующей квалификации, которые могут быть использованы для разработки системы. Кроме того, ресурсами проектирования являются материальные и финансовые затраты, доступные как в процессе создания, так и при последующей эксплуатации системы.
**_Работа в реальном времени_** с выдачей управляющей информации объектам — один из наиболее сложных режимов функционирования ПС. При этом от реального времени зависят не только моменты решения тех или иных задач, но и получаемые в результате данные. Реальное время в таких системах — важнейший параметр, определяющий выходные воздействия и функциональную связь между изменениями состояния реальных управляемых объектов и моделью их состояний в управляющей ЭВМ. Искажение значений времени может нарушить эту временную связь и привести к полному отказу системы управления. Длительность решения задач и скорость выдачи информации должны выдерживаться в соответствии с режимом работы и текущим состоянием источников информации и управляемых объектов. Это означает, что обработка информации и прогнозирование внешней ситуации должны осуществляться программами с более высокой скоростью, чем скорость реального управляемого процесса, с тем чтобы имелся определенный запас времени для принятия решений и формирования управляющих воздействий. Поэтому одной из важных для организации работы КП является проблема оперативного управления вычислительным процессом в реальном времени.
**_Разнообразие функций ПС_** объясняется тем, что в сложных системах один и тот же КП обычно используется для управления несколькими разнотипными объектами и, кроме того, является объектом управления для других систем более высокого ранга. В то же время управляющие программы сравнительно мало изменяются в течение длительного периода эксплуатации. Изменение характеристик или состава управляемых объектов, как правило, не вызывает фундаментальной переработки программ, так как возможность таких изменений обычно учитывается в процессе разработки. Управляющие ЭВМ, ориентированные на решение определенного класса задач, проектируются или выбираются с минимальными запасами вычислительных ресурсов. Значительная определенность задач, решаемых КП, позволяет весьма полно использовать аппаратуру и определять оптимальное соотношение между отдельными параметрами реализующих ЭВМ применительно к конкретным задачам.
Кроме того, особенность работы управляющих ПС заключается в том, что за ограниченное время решается большое количество различных функциональных задач и одновременно осуществляется обмен информацией с многочисленными внешними абонентами. Вследствие асинхронности работы большинства объектов системы управления данные от них могут поступать в случайные моменты времени, последовательность которых заранее не известна. Поэтому во многих КП строгая последовательность решения задач принципиально не может быть заранее определена или задана, так как она существенным образом зависит от поступающих сообщений и длительности решения тех или иных задач. Для «развязки» во времени процессов обмена и обработки сообщений используются буферные накопители сообщений при приеме и выдаче данных.
**_Надежность функционирования ПС_** при искажениях информации, сбоях и частичных отказах аппаратуры, которые могут возникать в процессе работы системы, — еще одна особенность ПС. Эти требования объясняются высокой степенью автоматизации процессов управления в ряде систем и особой важностью выполняемых функций. Работа в системе управления реальными объектами в большинстве случаев требует от КП надежного функционирования при длительном (иногда круглосуточном и многомесячном) непрерывном решении за данного набора задач. Так как сложность современных АСУ возрастает значительно быстрее, чем надежность используемой в них аппаратуры, то все более острой становится проблема обеспечения высокого качества выдаваемых результатов и сохранения работоспособности системы (пусть даже с худшими показателями) в условиях выхода из строя отдельных компонент аппаратуры. Для обеспечения необходимой надежности системы в КП широко применяются различные методы контроля, параллельное решение задач, а также совместная работа нескольких вычислительных машин в процессе решения единого комплекса задач управления.

---

## __Проблемы проектирования сложных программных средств: рациональное структурное построение, технология разработки, стандартизация; блочно-иерархический подход__.

Рациональное структурное построение означает создание организационной структуры, которая наилучшим образом способствует эффективной работе предприятия, обеспечивая четкое распределение полномочий, ответственности и функций, а также оптимальное взаимодействие между различными подразделениями.
**_Проблема рационального структурного построения_** комплексов программ возникает следующим образом. От качества решения функциональных задач в наибольшей степени зависит эффективность всей системы управления, а выбор методов их решения определяется конкретной проектируемой системой, ее назначением и ресурсами для реализации. Однако высокая автономная функциональная эффективность управляющих программ не может быть реализована, если структура алгоритма не обеспечивает достаточно полного использования основных ресурсов ЭВМ. Таким образом, возникает проблема рационального структурного построения комплексов программных средств. Эта проблема включает в себя задачи:
-     оптимизации структуры КП как с точки зрения максимального использования ресурсов ЭВМ, так и с точки зрения эффективности их проектирования и отладки;
-     организации последовательного решения функциональных задач в реальном времени и организации оперативного взаимодействия с внешними абонентами;
-     контроля вычислительного процесса и обеспечения надежного функционирования КП при наличии различных возмущений;
-     контроля достоверности выполнения функциональных программ и адаптации КП при изменении характеристик внешних абонентов или управляющей ЭВМ;
-     обеспечения простой корректировки КП при изменении в некоторых пределах характеристик внешних абонентов и гибкой модернизируемости ПС.
Эти задачи в той или иной степени должны решаться в любых ПС и слабо связаны с функциональным назначением управляющей системы. Поэтому методы их решения могут рассматриваться отдельно от конкретного целевого назначения системы управления.

**_Проблемы технологии разработки ПС_** в значительной степени определяются их сложностью. Особенно острой проблема технологии становится в тех случаях, когда объем сложного функционально связанного КП исчисляется сотнями тысяч команд. Длительность и трудоемкость проектирования КП такого объема приближается к длительности и трудоемкости разработки сложных комплексов аппаратуры и может оказаться определяющей для затрат и сроков проектирования всей управляющей системы. В этом случае длительность их разработки определяет качество и степень автоматизации технологии проектирования ПС, а в конечном итоге и качество управляющего комплекса. Проблема технологии разработки ПС включает задачи:
-     планирования и организации всего технологического процесса проектирования КП вплоть до серийного изготовления управляющих систем, построенных на базе созданных ПС;
-     разработки математических моделей алгоритмов и других компонент управляющей системы на всех стадиях их проектирования;
-     обеспечения программирования алгоритмов, включающего задачи автоматизации самого процесса программирования, унификации типовых компонент программ и т. д.;
-     обеспечения отладки программ с различными методами их контроля, обнаружения, диагностики ошибок и методами корректировки программ;
-     обеспечения испытаний программных компонент и всего КП;
-     автоматизации изготовления документов, обеспечивающих серийное воспроизведение, контроль качества и эксплуатацию программ в составе управляющей системы.
В целом структурные и технологические проблемы проектирования ПС можно объединить в единую проблему разработки методов и автоматизированных систем для проектирования сложных /С/7. К проектированию также необходим системный комплексный подход с учетом основных особенностей и критериев эффективности, характерных для создания сложных систем. Автоматизированные системы проектирования программ могут превосходить по сложности создаваемые с их помощью ПС. Однако возможность широкого применения систем проектирования для различных ПС делает рентабельной разработку автоматизированных систем проектирования программ.

**_Проблемы стандартизации программных средств_** в значительной степени аналогичны соответствующим проблемам для любых сложных промышленных изделий. Для значительного повышения производительности труда при разработке сложных КП требуется стандартизация и комплексная автоматизация всего технологического процесса создания программ. На программу должны задаваться технические условия, обеспечивающие детальную расшифровку ее функций и возможность полной проверки функционирования при массовом тиражировании. Эти мероприятия позволят обеспечить возможность широкого применения отдельных программ в различных системах без участия их разработчиков, замену устаревших компонент без нарушения остального комплекса программ. В идеале создание сложных ПС желательно сводить к сопряжению комплектующих изделий (групп программ или модулей) при минимальной разработке нестандартных компонент для сопряжения или выполнения новых специфических функций.
Необходимо стандартизировать структуру и формы представления документов на разработанную и испытанную программу. В настоящее время такой стандарт существует и носит название «Единая система программной документации».
Следующей задачей является стандартизация структуры и правил сопряжения программ по передаче управления и по обменной информации. Должны быть унифицированы правила описания и использования переменных, правила распределения памяти, требования к обмену информацией между отдельными программами, комплексами программ и автономными системами управления. Необходима унификация методов и правил построения сложных КП, общих правил иерархического построения и взаимодействия программ, решающих единую целевую задачу. Эти мероприятия должны существенно расширить применяемость каждой разработанной программы, что непосредственно отразится на повышении производительности труда программистов. Введение унифицированных методов эффективной организации вычислительного процесса в ЭВМ, правил распределения и использования многоуровневой памяти должно существенно повысить эффективность использования производительности и памяти вычислительных машин.
Создание крупных КП объемом в десятки и сотни тысяч команд привело к необходимости статистического подхода к оценке качества функционирования таких систем. Это, в частности, означает, что нужна стандартизация методов и требований к обеспечению и измерению качества сложных ПС. Эти методы должны позволять контролировать надежность функционирования созданных КП в реальных условиях, рассчитывать и прогнозировать возможную достоверность результатов в зависимости от затрат на отладку и принятых мер для автоматического выявления искажений и исправления результатов.
Многолетние попытки создать универсальный алгоритмический язык высокого уровня, обеспечивающий удобную разработку различных программ при высоком их качестве по занимаемой памяти ЭВМ и использованию ее производительности, до настоящего времени не увенчались успехом. В пределах каждого класса систем преимущественно используется 2-3 языка, причем практически всегда некоторая часть программ разрабатывается на автокодах. Стандартизацию языков программирования целесообразно рассматривать в пределах некоторых классов систем с сохранением возможности создания программ на автокодах. При этом стандартизация правил структурного построения и взаимодействия программ должна обеспечивать возможность использования программ, записанных на языках разного уровня, по крайней мере в пределах одного класса систем. Перечисленные задачи стандартизации должны объединяться единой технологической схемой и методологией создания сложных ПС.

### **Блочно-иерархический подход к созданию сложных систем**
Большинство сложных систем как в природе, так и в технике имеет иерархическую внутреннюю структуру. Это связано с тем, что обычно связи элементов сложных систем различны как по типу, так и по силе, что и позволяет рассматривать эти системы как некоторую _совокупность взаимозависимых подсистем_. Внутренние связи элементов таких подсистем сильнее, чем связи между подсистемами.
В свою очередь, используя то же различие связей, можно каждую подсистему разделить на подсистемы и т. д. до самого нижнего «элементарного» уровня, причем выбор уровня, компоненты которого следует считать элементарными, остается за исследователем. На элементарном уровне система, как правило, состоит из немногих типов подсистем, по-разному скомбинированных и организованных. Иерархии такого типа получили название «целое-часть».
Поведение системы в целом обычно оказывается сложнее поведения отдельных частей, причем из-за более сильных внутренних связей особенности системы в основном обусловлены отношениями между ее частями, а не частями как таковыми.
В природе существует еще один вид иерархии - иерархия «простое-сложное» или иерархия развития (усложнения) систем в процессе эволюции. В этой иерархии любая функционирующая система является результатом развития более простой системы. Именно данный вид иерархии реализуется механизмом наследования объектно-ориентированного программирования.
На этих свойствах иерархических систем строится _блочно-иерархический подход_ к их исследованию или созданию. Этот подход предполагает сначала создавать части таких объектов (блоки, модули), а затем собирать из них сам объект.
Процесс разбиения сложного объекта на сравнительно независимые части получил название _декомпозиции_. При декомпозиции учитывают, что связи между отдельными частями должны быть слабее, чем связи элементов внутри частей. Кроме того, чтобы из полученных частей можно было собрать разрабатываемый объект, в процессе декомпозиции необходимо определить все виды связей частей между собой.
При создании очень сложных объектов процесс декомпозиции выполняется многократно: каждый блок, в свою очередь, декомпозируют на части пока не получают блоки, которые сравнительно легко разработать. Данный метод разработки получил название _пошаговой_ _детализации._
Существенно и то, что в процессе декомпозиции стараются выделить аналогичные блоки, которые можно было бы разрабатывать на общей основе. Таким образом, обеспечивают увеличение степени повторяемости кодов и, соответственно, снижение стоимости разработки. Результат декомпозиции обычно представляют в виде схемы _иерархии_, на нижнем уровне которой располагают сравнительно простые блоки, а на верхнем - объект, подлежащий разработке.
На каждом иерархическом уровне описание блоков выполняют с определенной степенью детализации, _абстрагируясь_ от несущественных деталей. Следовательно, для каждого уровня используют свои формы документации и свои модели, отражающие сущность процессов, выполняемых каждым блоком. Так для объекта в целом, как правило, удается сформулировать лишь самые общие требования, а блоки нижнего уровня должны быть специфицированы так, чтобы из них действительно можно было собрать работающий объект. Другими словами, _чем_ _больше блок, тем более абстрактным должно быть его описание_.
При соблюдении этого принципа разработчик сохраняет возможность осмысления проекта и, следовательно, может принимать наиболее правильные решения на каждом этапе, что называют локальной оптимизацией (в отличие от глобальной оптимизации характеристик объектов, которая для действительно сложных объектов не всегда возможна).

_Примечание._ Следует иметь в виду, что понятие сложного объекта по мере совершенствования технологий изменяется, и то, что было сложным вчера, не обязательно останется сложным завтра. Итак, в основе блочно-иерархического подхода лежат декомпозиция и иерархическое упорядочение. Важную роль играют также следующие принципы: 1) непротиворечивость — контроль согласованности элементов между собой; 2) полнота – контроль на присутствие лишних элементов; 3) формализация – строгость методического подхода; 4) повторяемость – необходимость выделения одинаковых блоков для удешевления и ускорения разработки; 5) локальная оптимизация – оптимизация в пределах уровня иерархии.

Совокупность языков моделей, постановок задач, методов описаний некоторого иерархического уровня принято называть _уровнем проектирования._
Каждый объект в процессе проектирования, как правило, приходится рассматривать с нескольких сторон. Различные взгляды на объект проектирования принято называть _аспектами_ _проектирования._
Помимо того, что использование блочно-иерархического подхода делает возможным создание сложных систем, он также:
- упрощает проверку работоспособности, как системы в целом, так и отдельных блоков;
- обеспечивает возможность модернизации систем, например, замены ненадежных блоков с сохранением их интерфейсов.
Необходимо отметить, что использование блочно-иерархического подхода применительно к программным системам стало возможным только после конкретизации общих положений подхода и внесения некоторых изменений в процесс проектирования. При этом структурный подход учитывает только свойства иерархии «целое-часть», а объектный – использует еще и свойства иерархии «простое-сложное».

---

## __Жизненный цикл программного обеспечения, процессы жизненного цикла, связь между процессами.__
_Жизненным циклом_ программного обеспечения называют период от момента появления идеи создания некоторого программного обеспечения до момента завершения его поддержки фирмой-разработчиком или фирмой, выполнявшей сопровождение.
Состав процессов жизненного цикла регламентируется международным стандартом ISO/IEC 12207: 1995 «Information Technologe - Software Life Cycle Processes» («Информационные технологии - Процессы жизненного цикла программного обеспечения»). ISO – International Organization for Standardization - Международная организация по стандартизации. IЕС – International Electrotechnical Commission - Международная комиссия по электротехнике.
Этот стандарт описывает структуру жизненного цикла программного обеспечения и его процессы. _Процесс_ жизненного цикла определяется как совокупность взаимосвязанных действий, преобразующих некоторые входные данные в выходные. Каждый процесс характеризуется определенными задачами и методами их решения, а также исходными данными и результатами.

Основные процессы:
- приобретение
- поставка
- разработка
- эксплуатация
- сопровождение
Организационные процессы:
- управление
- усовершенствование
- создание инфраструктуры
- обучение
Вспомогательные процессы
- документирование
- управление конфигурацией
- управление качеством (обеспечение качества, верификация, аттестация, совместная оценка, аудит)
- разрешение проблем

Процесс разработки (development process) в соответствии со стандартом предусматривает действия и задачи, выполняемые разработчиком, и охватывает работы по созданию программного обеспечения и его компонентов в соответствии с заданными требованиями, включая оформление проектной и эксплуатационной документации, а также подготовку материалов, необходимых для проверки работоспособности и соответствия качества программных продуктов, материалов,  необходимых для обучения персонала, и т. д.

По стандарту процесс разработки включает следующие действия:
- _подготовительную работу_ – выбор модели жизненного цикла, стандартов, методов и средств разработки, а также составление плана работ;
- _анализ требований к системе_ – определение ее функциональных возможностей, пользовательских требований, требований к надежности и безопасности, требований к внешним интерфейсам и т. д.;
- _проектирование архитектуры системы_ – определение состава необходимого оборудования, программного обеспечения и операций, выполняемых обслуживающим персоналом;
- _анализ требований к программному обеспечению_ – определение функциональных возможностей, включая характеристики производительности, среды функционирования компонентов, внешних интерфейсов, спецификаций надежности и безопасности, эргономических требований, требований к используемым данным, установке, приемке, пользовательской документации, эксплуатации и сопровождению;
- _проектирование архитектуры программного обеспечения_ – определение структуры программного обеспечения, документирование интерфейсов его компонентов, разработку предварительной версии пользовательской документации, а также требований к тестам и планам интеграции;
- _детальное проектирование программного обеспечения_ – подробное описание компонентов программного обеспечения и интерфейсов между ними, обновление пользовательской документации, разработка и документирование требований к тестам и плана тестирования компонентов программного обеспечения, обновление плана интеграции компонентов;
- _кодирование и тестирование программного обеспечения_ – разработку и документирование каждого компонента, а также совокупности тестовых процедур и данных для их тестирования, тестирование компонентов, обновление пользовательской документации, обновление плана интеграции программного обеспечения;
- _интеграцию программного обеспечения_ – сборку программных компонентов в соответствии с планом интеграции и тестирование программного обеспечения на соответствие квалификационным требованиям, представляющих собой набор критериев или условий, которые необходимо выполнить, чтобы квалифицировать программный продукт, как соответствующий своим спецификациям и готовый к использованию в заданных условиях эксплуатации;
- _квалификационное тестирование программного обеспечения_ – тестирование программного обеспечения в присутствии заказчика для демонстрации его соответствия требованиям и готовности к эксплуатации; при этом проверяется также готовность и полнота технической и пользовательской документации
- _интеграцию системы_ – сборку всех компонентов системы, включая программное обеспечение и оборудование;
- _квалификационное тестирование системы_ – тестирование системы на соответствие требованиям к ней и проверка оформления и полноты документации;
- _установку программного обеспечения_ – установку программного обеспечения на оборудовании заказчика и проверку его работоспособности;
- _приемку программного обеспечения_ – оценку результатов квалификационного тестирования программного обеспечения и системы в целом и документирование результатов оценки совместно с заказчиком, окончательную передачу программного обеспечения заказчику.

---

## __Основные процессы жизненного цикла: приобретение, поставка, разработка, эксплуатация, сопровождение.__
**_Процесс приобретения_** (acquisition process) состоит из действий и задач заказчика, приобретающего ПО. Данный процесс охватывает следующие действия:
1) инициирование приобретения;
2) подготовку заявочных предложений;
3) подготовку и корректировку договора;
4) надзор за деятельностью поставщика;
5) приемку и завершение работ.

**_Процесс поставки_** (supply process) охватывает действия и задачи, выполняемые поставщиком, который снабжает заказчика программным продуктом или услугой. Данный процесс включает следующие действия:
1) инициирование поставки;
2) подготовку ответа на заявочные предложения;
3) подготовку договора;
4) планирование;
5) выполнение и контроль;
6) проверку и оценку;
7) поставку и завершение работ.

**_Процесс разработки_** (development process) предусматривает действия и задачи, выполняемые разработчиком, и охватывает работы по созданию ПО и его компонентов в соответствии с заданными требованиями, включая оформление проектной и эксплуатационной документации, подготовку материалов, необходимых для проверки работоспособности и соответствующего качества программных продуктов, материалов, необходимых для организации обучения персонала, и т.д.

Процесс разработки включает следующие действия:
1) подготовительную работу;
2) анализ требований к системе;
3) проектирование архитектуры системы;
4) анализ требований к ПО;
5) проектирование архитектуры ПО;
6) детальное проектирование ПО;
7) кодирование и тестирование ПО;
8) интеграцию ПО;
9) квалификационное тестирование ПО;
10) интеграцию системы;
11) квалификационное тестирование системы;
12) установку ПО;
13) приемку ПО.

**_Процесс эксплуатации_** (operation process) охватывает действия и задачи оператора — организации, эксплуатирующей систему. Данный процесс включает следующие действия:
1) подготовительную работу;
2) эксплуатационное тестирование;
3) эксплуатацию системы;
4) поддержку пользователей.

**_Процесс сопровождения (maintenance process)_** предусматривает действия и задачи, выполняемые сопровождающей организацией (службой сопровождения). Данный процесс активизируется при изменениях (модификациях) программного продукта и соответствующей документации, вызванных возникшими проблемами или потребностями в модернизации либо адаптации ПО. В соответствии со стандартом IEE-90 под _сопровождением_ понимается внесение изменений в ПО в целях исправления ошибок, повышения производительности или адаптации к изменившимся условиям работы или требованиям. Изменения, вносимые в существующее ПО, не должны нарушать его целостности. Процесс сопровождения включает перенос ПО в другую среду (миграцию) и заканчивается снятием ПО с эксплуатации.

Процесс сопровождения охватывает следующие действия:
1) подготовительную работу;
2) анализ проблем и запросов на модификацию ПО
3) модификацию ПО;
4) проверку и приемку;
5) перенос ПО в другую среду;
6) снятие ПО с эксплуатации.

---

## __Вспомогательные процессы жизненного цикла: документирование, управление конфигурацией, обеспечение качества, верификация, аттестация, совместная оценка, аудит, разрешение проблем.__
**Процесс документирования** предусматривает формализованное описание информации, созданной в течение ЖЦ ПО. Данный процесс состоит из набора действий, с помощью которых планируют, проектируют, разрабатывают, выпускают, редактируют, распространяют и сопровождают документы, необходимые для всех заинтересованных лиц, таких, как руководство, технические специалисты и пользователи системы.

Процесс документирования включает следующие действия:
1) подготовительную работу;
2) проектирование и разработку;
3) выпуск документации;
4) сопровождение.

**Процесс управления конфигурацией** предполагает применение административных и технических процедур на всем протяжении ЖЦ ПО для определения состояния компонентов ПО в системе, управления модификациями ПО, описания и подготовки отчетов о состоянии компонентов ПО и запросов на модификацию, обеспечения полноты, совместимости и корректности компонентов ПО, управления хранением и поставкой ПО. Управление конфигурацией позволяет организовать, систематически учитывать и контролировать внесение изменений в ПО на всех стадиях ЖЦ.

Процесс управления конфигурацией включает следующие действия:
1) подготовительную работу;
2) идентификацию конфигурации;
3) контроль за конфигурацией;
4) учет состояния конфигурации;
5) оценку конфигурации;
6) управление выпуском и поставку.

**Процесс обеспечения качества** обеспечивает соответствующие гарантии того, что ПО и процессы его ЖЦ соответствуют заданным требованиям и утвержденным планам.  Под качеством ПО понимается совокупность свойств, которые характеризуют способность ПО удовлетворять заданным требованиям. Для получения достоверных оценок создаваемого ПО процесс обеспечения его качества должен происходить независимо от субъектов, непосредственно связанных с разработкой ПО. При этом могут использоваться результаты других вспомогательных процессов, таких, как верификация, аттестация, совместная оценка, аудит и разрешение проблем.

Процесс обеспечения качества включает следующие действия:
1) подготовительную работу;
2) обеспечение качества продукта;
3) обеспечение качества процесса;
4) обеспечение прочих показателей качества системы.

**Процесс верификации** состоит в определении того, что программные продукты, являющиеся результатами некоторого действия, полностью удовлетворяют требованиям или условиям, обусловленным предшествующими действиями (верификация в узком смысле означает формальное доказательство правильности ПО). Для повышения эффективности верификация должна как можно раньше интегрироваться с использующими ее процессами (такими, как поставка, разработка, эксплуатация или сопровождение). Данный процесс может включать анализ, оценку и тестирование. Верификация может проводиться с различными степенями независимости. Степень независимости может варьироваться от выполнения верификации самим исполнителем или другим специалистом данной организации до ее выполнения специалистом другой организации с различными вариациями. Если процесс верификации осуществляется организацией, не зависящей от поставщика, разработчика, оператора или службы сопровождения, то он называется процессом независимой верификации.

Процесс верификации включает следующие действия:
1) подготовительную работу;
2) верификацию.

В процессе верификации проверяются следующие условия:
- непротиворечивость требований к системе и степень учета потребностей пользователей;
- возможности поставщика выполнить заданные требования;
- соответствие выбранных процессов ЖЦ ПО условиям договора;
- адекватность стандартов, процедур и среды разработки процессам ЖЦ ПО;
- соответствие проектных спецификаций ПО заданным требованиям;
- корректность описания в проектных спецификациях входных и выходных данных, последовательности событий, интерфейсов, логики и т.д.;
- соответствие кода проектным спецификациям и требованиям;
- тестируемость и корректность кода, его соответствие принятым стандартам кодирования;
- корректность интеграции компонентов ПО в систему;
- адекватность, полнота и непротиворечивость документации.

**Процесс аттестации** предусматривает определение полноты соответствия заданных требований и созданной системы или программного продукта их конкретному функциональному назначению. Под аттестацией обычно понимается подтверждение и оценка достоверности проведенного тестирования ПО. Аттестация должна гарантировать полное соответствие ПО спецификациям, требованиям и документации, а также возможность его безопасного и надежного применения пользователем. Аттестацию рекомендуется выполнять путем тестирования во всех возможных ситуациях и использовать при этом независимых специалистов. Аттестация может проводиться на начальных стадиях ЖЦ ПО или как часть работы по приемке ПО. Аттестация, так же как и верификация, может осуществляться с различными степенями независимости. Если процесс аттестации выполняется организацией, не зависящей от поставщика, разработчика, оператора или службы сопровождения, то он называется процессом независимой аттестации.

Процесс аттестации включает следующие действия:
1) подготовительную работу;
2) аттестацию.

**Процесс совместной оценки** предназначен для оценки состояния работ по проекту и ПО, создаваемому при выполнении данных работ (действий). Он сосредоточен в основном на контроле планирования и управления ресурсами, персоналом, аппаратурой и инструментальными средствами проекта. Оценка применяется как на уровне управления проектом, так и на уровне технической реализации проекта и проводится в течение всего срока действия договора. Данный процесс может выполняться двумя любыми сторонами, участвующими в договоре, при этом одна сторона проверяет другую.

Процесс совместной оценки включает следующие действия:
1) подготовительную работу;
2) оценку управления проектом;
3) техническую оценку.

**Процесс аудита** представляет собой определение соответствия требованиям, планам и условиям договора. Аудит может выполняться двумя любыми сторонами, участвующими в договоре, когда одна сторона проверяет другую.

Аудит – это ревизия (проверка), проводимая компетентным органом (лицом) в целях обеспечения независимой оценки степени соответствия ПО или процессов установленным требованиям. Аудит служит для установления соответствия реальных работ и отчетов требованиям, планам и контракту. Аудиторы (ревизоры) не должны иметь прямой зависимости от разработчиков ПО. Они определяют состояние работ, использование ресурсов, соответствие документации спецификациям и стандартам, корректность тестирования. Процесс аудита включает следующие действия:
1) подготовительную работу;
2) аудит.

**Процесс разрешения проблем** предусматривает анализ и решение проблем (включая обнаруженные несоответствия), независимо от их происхождения или источника, которые обнаружены в ходе разработки, эксплуатации, сопровождения или других процессов. Каждая обнаруженная проблема должна быть идентифицирована, описана, проанализирована и разрешена. Процесс разрешения проблем включает следующие действия:
1) подготовительную работу;
2) разрешение проблем.

---

## __Организационные процессы жизненного цикла: управление, создание инфраструктуры, усовершенствование, обучение.__

**_Процесс управления_** состоит из действий и задач, которые могут выполняться любой стороной, управляющей своими процессами. Данная сторона (менеджер) отвечает за управление выпуском продукта, управление проектом и задачами соответствующих процессов, таких, как приобретение, поставка, разработка, эксплуатация, сопровождение и др.
Процесс управления включает следующие действия:
1) инициирование и определение области управления;
2) планирование;
3) выполнение и контроль;
4) проверку и оценку;
5) завершение.

**_Процесс создания инфраструктуры_** охватывает выбор и поддержку (сопровождение) технологии, стандартов и инструментальных средств, выбор и установку аппаратных и программных средств, используемых для разработки, эксплуатации или сопровождения ПО. Инфраструктура должна модифицироваться и сопровождаться в соответствии с изменениями требований к соответствующим процессам. Инфраструктура, в свою очередь, является одним из объектов управления конфигурацией.
Процесс создания инфраструктуры включает следующие действия:
1) подготовительную работу;
2) создание инфраструктуры;
3) сопровождение инфраструктуры.

**_Процесс усовершенствования_** предусматривает оценку, измерение, контроль и усовершенствование процессов ЖЦ ПО. Данный процесс включает следующие действия:
1) создание процесса;
2) оценку процесса;
3) усовершенствование процесса.
Усовершенствование процессов ЖЦ ПО направлено на повышение производительности труда всех участвующих в них специалистов за счет совершенствования используемой технологии, методов управления, выбора инструментальных средств и обучения персонала. Усовершенствование основано на анализе достоинств и недостатков каждого процесса. Такому анализу в большой степени способствует накопление в организации исторической, технической, экономической и иной информации по реализованным проектам.

**_Процесс обучения_** охватывает первоначальное обучение и последующее постоянное повышение квалификации персонала. Приобретение, поставка, разработка, эксплуатация и сопровождение ПО в значительной степени зависят от уровня знаний и квалификации персонала. Например, разработчики ПО должны пройти необходимое обучение методам и средствам программной инженерии. Содержание процесса обучения определяется требованиями к проекту. Оно должно учитывать необходимые ресурсы и технические средства обучения. Должны быть разработаны и представлены методические материалы, необходимые для обучения пользователей в соответствии с учебным планом.
Процесс обучения включает следующие действия:
1) подготовительную работу;
2) разработку учебных материалов;
3) реализацию плана обучения.

---

## __Модели жизненного цикла: поэтапная, каскадная, спиральная, переиспользования и реверсивной инженерии.__

**Каскадная модель**. 
![](file:///C:/Users/843E~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif)
Первоначально (1970-1985 годы) была предложена и использовалась _каскадная схема разработки программного обеспечения_, которая предполагала, что переход на следующую стадию осуществляется после того, как полностью будут завершены проектные операции предыдущей стадии и получены все исходные данные для следующей стадии.
Достоинствами такой схемы являются:
- получение в конце каждой стадии законченного набора проектной документации, отвечающего требованиям полноты и согласованности;
- простота планирования процесса разработки.
Именно такую схему и используют обычно при блочно-иерархическом подходе к разработке сложных _технических_ объектов, обеспечивая очень высокие параметры эффективности разработки. Однако данная схема оказалась применимой только к созданию систем, для которых в самом начале разработки удавалось точно и полно сформулировать все требования. Это уменьшало вероятность возникновения в процессе разработки проблем, связанных с принятием неудачного решения на предыдущих стадиях. На практике такие разработки встречается крайне редко.
В целом необходимость возвратов на предыдущие стадии обусловлена следующими причинами:
- неточные спецификации, уточнение которых в процессе разработки может привести к необходимости пересмотра уже принятых решений;
- изменение требований заказчика непосредственно в процессе разработки;
- быстрое моральное устаревание используемых технических и программных средств;
- отсутствие удовлетворительных средств описания разработки на стадиях постановки задачи, анализа и проектирования.
Отказ от уточнения (изменения) спецификаций приведет к тому, что законченный продукт не будет удовлетворять потребности пользователей. При отказе от учета смены оборудования и программной среды пользователь получит морально устаревший продукт. А отказ от пересмотра неудачных проектных решений приводит к ухудшению структуры программного продукта и, соответственно, усложнит, растянет по времени и удорожит процесс его создания. Реальный процесс разработки, таким образом, носит итерационный характер.

**Поэтапная модель с промежуточным контролем.**
![[Pasted image 20250916192503.png]]
Схема, поддерживающая итерационный характер процесса разработки, была названа _схемой с промежуточным контролем_. Контроль, который выполняется по данной схеме после завершения каждого этапа, позволяет при необходимости вернуться на любой уровень и внести необходимые изменения. Основная опасность использования такой схемы связана с тем, что разработка никогда не будет завершена, постоянно находясь в состоянии уточнения и усовершенствования.

**Спиральная модель.** 
![](file:///C:/Users/843E~1/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif)
Для преодоления перечисленных проблем в середине 80-х годов XX в, была предложена _спиральная схема_. В соответствии с данной схемой программное обеспечение создается не сразу, а итерационно с использованием метода прототипирования, базирующегося на создании прототипов. Именно появление прототипирования привело к тому, что процесс модификации программного обеспечения перестал восприниматься, как «необходимое зло», а стал восприниматься как отдельный важный процесс.
_Прототипом_ называют действующий программный продукт, реализующий отдельные функции и внешние интерфейсы разрабатываемого программного обеспечения. На первой итерации, как правило, специфицируют, проектируют, реализуют и тестируют интерфейс пользователя. На второй - добавляют некоторый ограниченный набор функций. На последующих этапах этот набор расширяют, наращивая возможности данного продукта.
Основным достоинством данной схемы является то, что, начиная с некоторой итерации, на которой обеспечена определенная функциональная полнота, продукт можно предоставлять пользователю, что позволяет:
- сократить время до появления первых версий программного продукта;
- заинтересовать большое количество пользователей, обеспечивая быстрое продвижение следующих версий продукта на рынке;
- ускорить формирование и уточнение спецификаций за счет появления практики использования продукта;
- уменьшить вероятность морального устаревания системы за время разработки.
Основной проблемой использования спиральной схемы является определение моментов перехода на следующие стадии. Для ее решения обычно ограничивают сроки прохождения каждой стадии, основываясь на экспертных оценках.

### **Модель Переиспользования (Reuse-Oriented Model)**
Эта модель жизненного цикла ставит во главу угла использование уже существующих программных компонентов. Вместо того чтобы создавать все части системы с нуля, разработчики активно ищут, адаптируют и интегрируют готовые модули, библиотеки или сервисы. Это могут быть как компоненты из предыдущих проектов компании, так и сторонние коммерческие продукты (COTS - Commercial Off-The-Shelf).
Основная идея — сократить время и стоимость разработки, а также повысить надежность за счет использования уже проверенных и отлаженных решений.

**Основные этапы:**
1. **Анализ компонентов.** На основе первоначальных требований производится поиск существующих компонентов, которые могут быть использованы в проекте.
2. **Модификация требований.** Требования к системе могут быть скорректированы в зависимости от того, какие компоненты доступны. Иногда проще немного изменить требование, чем создавать сложный компонент с нуля.
3. **Проектирование системы с учетом переиспользования.** Архитектура системы выстраивается как "каркас" для интеграции выбранных компонентов. На этом этапе проектируются только те части, для которых не нашлось готовых решений.
4. **Разработка и интеграция.** Новые компоненты разрабатываются и объединяются с уже существующими в единую систему.

**Преимущества:**
- **Сокращение времени и затрат.** Переиспользование кода значительно ускоряет разработку.
- **Повышение надежности.** Используемые компоненты, как правило, уже были протестированы в других проектах.

**Недостатки:**
- **Компромисс в требованиях.** Иногда приходится жертвовать некоторыми функциями, если доступные компоненты не полностью им соответствуют.
- **Сложность интеграции.** "Склеивание" компонентов от разных разработчиков может вызвать проблемы совместимости.


###  **Модель Реверсивной Инженерии (Reverse Engineering)**

Реверсивная инженерия (или обратная разработка) — это не самостоятельная модель жизненного цикла для создания нового ПО, а скорее **процесс**, который используется для анализа и понимания уже существующей системы. Он становится ключевым элементом в моделях **реинженерии** (re-engineering), цель которых — не создать новый продукт, а кардинально переработать и улучшить старый.

**Цели и место в жизненном цикле:**
Процесс реинженерии, включающий реверсивную инженерию, обычно выглядит так:
1. **Реверсивная инженерия (Reverse Engineering).** Исходный код или работающая программа анализируется для восстановления архитектуры, бизнес-логики и моделей данных. По сути, это движение "от кода к проекту". На этом этапе создается понимание системы.
2. **Реструктуризация (Alteration/Transformation).** На основе полученных знаний система преобразуется. Это может включать улучшение структуры кода, перенос на новый язык программирования или платформу, изменение архитектуры для повышения производительности или безопасности.
3. **Прямая инженерия (Forward Engineering).** Модернизированная система реализуется, как в обычном цикле разработки: пишется новый код, происходит тестирование и внедрение обновленной версии продукта.

**Когда это применяется?**
- Для модернизации устаревших (legacy) систем.
- При восстановлении утерянной документации.
- Для анализа вредоносного ПО.
- При переносе системы на новую технологическую платформу.

Таким образом, модель переиспользования фокусируется на сборке нового из готовых "кирпичиков", а реверсивная инженерия является отправной точкой для глубокой переработки уже существующего программного обеспечения.

---

## __Стадии жизненного цикла: формирование требований, проектирование, реализация, тестирование, внедрение, эксплуатация и сопровождение, снятие с эксплуатации. Взаимосвязь между стадиями и процессами жизненного цикла, матрица фазы-функции.__

**Постановка задачи.** В процессе _постановки задачи_ четко формулируют назначение программного обеспечения и определяют основные требования к нему. Каждое требование представляет собой описание необходимого или желаемого свойства программного обеспечения.
Различают _функциональные требования_, определяющие функции, которые должно выполнять разрабатываемое программное обеспечение, и _эксплуатационные требования_, определяющие особенности его функционирования.
Требования к программному обеспечению, имеющему _прототипы_, обычно определяют по аналогии, учитывая структуру и характеристики уже существующего программного обеспечения. Для формулирования требований к программному обеспечению, не имеющему аналогов, иногда необходимо провести специальные исследования, называемые предпроектными. В процессе таких исследований определяют разрешимость задачи, возможно, разрабатывают методы ее решения (если они новые) и устанавливают наиболее существенные характеристики разрабатываемого программного обеспечения. Для выполнения предпроектных исследований, как правило, заключают договор на выполнение научно-исследовательских работ. В любом случае этап постановки задачи заканчивается разработкой _технического задания_, фиксирующего принципиальные требования, и принятием основных проектных решений.

**Анализ требований и определение спецификаций.** _Спецификациями_ называют точное формализованное описание функций и ограничений разрабатываемого программного обеспечения. Соответственно различают _функциональные_ и _эксплуатационные_ спецификации.
Совокупность спецификаций представляет собой _общую_ логическую модель проектируемого программного обеспечения.
Для получения спецификаций выполняют анализ требований технического задания, формулируют содержательную постановку задачи, выбирают математический аппарат формализации, строят модель предметной области, определяют подзадачи и выбирают или разрабатывают методы их решения. Часть спецификаций может быть определена в процессе предпроектных исследований и, соответственно, зафиксирована в техническом задании.
На этом этапе также целесообразно сформировать тесты для поиска ошибок в проектируемом программном обеспечении, обязательно указав ожидаемые результаты.

**Проектирование.** Основной задачей этого этапа является определение _подробных_ спецификаций разрабатываемого программного обеспечения. Процесс проектирования сложного программного обеспечения обычно включает:
- проектирование общей структуры - определение основных компонентов и их взаимосвязей;
- декомпозицию компонентов и построение структурных иерархий в соответствии с рекомендациями блочно-иерархического подхода;
- проектирование компонентов.

Результатом проектирования является _детальная модель_ разрабатываемого программного обеспечения вместе со спецификациями его компонентов всех уровней. Тип модели зависит от выбранного подхода (структурный, объектный или компонентный) и конкретной технологии проектирования. Однако в любом случае процесс проектирования охватывает как проектирование программ (подпрограмм) и определение взаимосвязей между ними, так и проектирование данных, с которыми взаимодействуют эти программы или подпрограммы.
Принято различать также два аспекта проектирования:
- логическое проектирование, которое включает те проектные операции, которые непосредственно не зависят от имеющихся технических и программных средств, составляющих среду функционирования будущего программного продукта;
- физическое проектирование - привязка к конкретным техническим и программным средствам среды функционирования, т. е. учет ограничений, определенных в спецификациях.

**Реализация.** Реализация представляет собой процесс поэтапного написания кодов программы на выбранном языке программирования (кодирование), их тестирование и отладку.

**Внедрение** (тестирование, опытная эксплуатация) - комплексная отладка подсистем ИС, обучение персонала, поэтапное внедрение информационной системы в эксплуатацию по подразделениям экономического объекта, оформление акта о приемо-сдаточных испытаниях ИС.  Система редко вводится полностью. Как правило, это процесс постепенный или итерационный. Ввод в эксплуатацию проходит как минимум три стадии:
- первоначальная загрузка информации;
- накопление информации;
- выход на проектную мощность (то есть собственно переход к этапу эксплуатации).
Первоначальная загрузка информации инициирует довольно узкий спектр ошибок: в основном речь идет о проблемах рассогласования данных при загрузке и о собственных ошибках загрузчиков.
В период накопления информации из информационной системы выявляется наибольшее количество ошибок, связанных с многопользовательским доступом. Вторая категория исправлений связана с тем, что пользователя не устраивает интерфейс. Здесь не всегда нужно выполнять абсолютно все пожелания пользователя, иначе процесс ввода в эксплуатацию будет бесконечным.
Выход системы на проектную мощность в хорошем варианте – это доводка мелких ошибок и редкие серьезные ошибки.

**Эксплуатация информационной системы** – сбор рекламации и статистики о функционировании ИС, обслуживание пользователей, возможно устранение незначительных ошибок и недоработок (сейчас это делается повсеместно с помощью распространения так называемых patсh-файлов), оформление требований к модернизации ИС и ее выполнение.

**Сопровождение.** Сопровождение – это процесс создания и внедрения новых версий программного продукта. Причинами выпуска новых версий могут служить:
- необходимость исправления ошибок, выявленных в процессе эксплуатации предыдущих версий;
- необходимость совершенствования предыдущих версий, например, улучшения интерфейса, расширения состава выполняемых функций или повышения его производительности;
- изменение среды функционирования, например, появление новых технических средств и/или программных продуктов, с которыми взаимодействует сопровождаемое программное обеспечение.
На этом этапе в программный продукт вносят необходимые изменения, которые так же, как в остальных случаях, могут потребовать пересмотра проектных решений, принятых на любом предыдущем этапе. С изменением модели жизненного цикла программного обеспечения роль этого этапа существенно возросла, так как продукты теперь создаются итерационно: сначала выпускается сравнительно простая версия, затем следующая с большими возможностями, затем следующая и т. д. Именно это и послужило причиной выделения этапа сопровождения в отдельный процесс жизненного цикла в соответствии с стандартом ISO/IEC 12207.
Рассматриваемый стандарт только называет и определяет процессы жизненного цикла программного обеспечения, не конкретизируя в деталях, как реализовывать или выполнять действия и задачи, включенные в эти процессы. Эти вопросы регламентируются соответствующими методами, методиками и т. п. Прежде, чем перейти к подробному рассмотрению последних, проанализируем эволюцию схем разработки программного обеспечения от момента их появления до настоящего времени.

---
