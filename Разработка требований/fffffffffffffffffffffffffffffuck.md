зачем мне всё это... ну это явно бесполезная хуйня, которую вспоминают только преподы в вузах
```table-of-contents
style:nestedOrderedList
```

---
## __Программа, комплекс программ, программное средство, программное обеспечение, программный продукт. Концепция программного изделия: непосредственная производительная сила, промышленная технология проектирования программ, стандарты и сборочное программирование, контроль и управление качеством программ, экономика программных средств, подготовка специалистов по всем этапам жизненного цикла программ, разделение труда специалистов в проектных организациях.__

__Программа__ — упорядоченная последовательность команд (инструкций) компьютера или операторов для решения задачи.
__Комплекс программ__ — это набор взаимосвязанных программ для решения определённой проблемы (или задачи).
__Программное средство__ — это объект, состоящий из программ, процедур, правил и сопутствующих им документации и данных.
__Программное обеспечение__ — это совокупность программ системы обработки информации и программных документов, необходимых для эксплуатации этих программ
__Программный продукт (или программное изделие)__ — это комплекс взаимосвязанных программ для решения определенной проблемы (задачи) массового спроса, подготовленный к реализации как любой вид промышленной продукции. _Программная
продукция_ — это программа (программный комплекс, программная система),
которую стремятся продать на широком рынке тысячам, миллионам пользователей.

### Концепция программного изделия
Программное изделие (или программный продукт) — это результат промышленного подхода к разработке программного обеспечения. Этот подход рассматривает ПО не как результат творчества одиночки, а как продукт, созданный по чётким инженерным и экономическим правилам.
#### **Непосредственная производительная сила**
В современной экономике программное обеспечение перестало быть просто вспомогательным инструментом. Оно стало **прямой производительной силой**, то есть средством производства, которое непосредственно участвует в создании товаров и услуг. Автоматизация производства, логистики, финансов, аналитики — всё это примеры того, как ПО напрямую увеличивает производительность и создаёт стоимость.
#### **Промышленная технология проектирования программ**
Это переход от "кустарного" написания кода к фабричному производству. Промышленный подход включает:
- **Методологии разработки**: Использование строгих моделей, таких как Waterfall (Водопадная), Agile, Scrum, для организации процесса.
- **Автоматизация**: Применение инструментов для автоматической сборки, тестирования (CI/CD) и развёртывания программ.
- **Моделирование**: Использование языков вроде UML для проектирования архитектуры системы перед написанием кода.
#### **Стандарты и сборочное программирование**
Чтобы создавать большие и сложные системы, нужны общие правила и готовые блоки.
- **Стандарты**: Это набор правил и соглашений (например, стандарты кодирования, протоколы обмена данными вроде HTTP, стандарты безопасности), которые обеспечивают совместимость и предсказуемость.
- **Сборочное программирование**: Концепция, при которой программа не пишется с нуля, а собирается из уже существующих, проверенных компонентов, библиотек и фреймворков. Это значительно ускоряет разработку и повышает надёжность.
#### **Контроль и управление качеством программ (QA)**
Качество продукта — ключевой фактор его успеха. В промышленной разработке это не случайность, а результат целенаправленной деятельности, включающей:
- **Тестирование**: Проверка продукта на ошибки (баги) на разных уровнях (модульное, интеграционное, системное).
- **Анализ кода (Code Review)**: Проверка кода другими разработчиками для поиска ошибок и улучшения его качества.
- **Метрики качества**: Использование показателей (например, количество дефектов на тысячу строк кода) для оценки и контроля качества.
#### **Экономика программных средств**
Программный продукт — это экономический актив. Его разработка требует инвестиций, а результат должен приносить прибыль. Экономика ПО включает:
- **Оценку трудозатрат и бюджета**: Планирование ресурсов, необходимых для создания продукта.
- **Ценообразование**: Определение стоимости продукта на основе затрат, ценности для клиента и рыночной конъюнктуры (например, продажа лицензий, подписка).
- **Совокупная стоимость владения (TCO)**: Учёт не только стоимости разработки, но и затрат на поддержку, обновления и сопровождение продукта в течение его жизненного цикла.
#### **Подготовка специалистов по всем этапам жизненного цикла**
Промышленное производство ПО требует команды профессионалов с разными навыками, которые покрывают весь **жизненный цикл программы**: от идеи до вывода из эксплуатации. Это аналитики, архитекторы, разработчики, тестировщики, DevOps-инженеры, менеджеры проектов, специалисты по поддержке. Система образования и корпоративного обучения должна готовить кадры для каждой из этих ролей.
#### **Разделение труда специалистов**
Как и на любом заводе, в крупных проектах по разработке ПО существует чёткое разделение труда. Каждый специалист фокусируется на своей области:
- **Бизнес-аналитик** определяет, _что_ нужно сделать.
- **Системный архитектор** решает, _как_ это будет спроектировано в целом.
- **Разработчик (программист)** пишет код, реализуя конкретные функции.
- **Тестировщик (QA-инженер)** проверяет, _правильно ли_ всё работает.
- **Менеджер проекта** следит за сроками, бюджетом и командой.
## __Технология программирования, основные этапы развития: «стихийное» программирование, структурное программирование, объектно-ориентированное программирование, компонентное программирование.__

__Технологией программирования__ — это (1) совокупность методов и средств, используемых в процессе разработки программного обеспечения, или (2) система методов, способов и приемов разработки и отладки программ.

___В широком смысле следует понимать технологию разработки программного средства, как совокупность абсолютно всех технологических процессов его создания – от момента зарождения идеи о данном программном средстве (ПС) до составления необходимой программной документации.___

Как любая другая технология, технология программирования представляет собой набор технологических инструкций, включающих:
- указание последовательности выполнения технологических операций;
- перечисление условий, при которых выполняется та или иная операция;
- описания самих операций, где для каждой операции определены исходные данные, результаты, а также инструкции, нормативы, стандарты, критерии, методы оценки и т. п.

### Стихийное программирование (до 60-х гг. XX в.)
До середины 1960-х гг. преимущественно использовалась неструктурированная, «стихийная» технология программирования. Структура первых простейших программ состояла собственно из программы, написанной на машинном языке (в двоичных или шестнадцатеричных кодах) и обрабатываемых ею данных.
Появление машинно-ориентированных языков (ассемблеров) позволило программистам вместо кодов использовать мнемонические обозначения кодов операций и символические имена данных. Программы стали «читаемыми».
Появление языков программирования высокою уровня (FORTRAN, ALGOL) позволило снизить уровень детализации операций. Большим достижением этих языков стала возможность использования подпрограмм. Были созданы большие библиотеки различных подпрограмм. Теперь структура программы состояла из основной программы, области глобальных данных и набора подпрограмм. Недостаток такой структуры — возрастание вероятности искажения части глобальных данных какой-либо подпрограммой при увеличении количества подпрограмм. Для сокращения таких ошибок было предложено размещать в подпрограммах локальные данные. Появилась возможность совместной разработки ПО несколькими программистами.
Использовался метод программирования «снизу—вверх», т.е. сначала разрабатывались простые подпрограммы, а затем строилась сложная программа путем их сборки. При сборке программы появлялось большое количество ошибок согласования, а при их исправлении появлялись новые ошибки. Процесс тестирования и отладки занимал 80% времени разработки ПО.
### Структурное программирование (1960—1970-е гг.)
_Структурный подход к программированию_ представляет собой совокупность рекомендуемых технологических приемов, охватывающих выполнение всех этапов разработки программного обеспечения. В основе структурного подхода лежит Декомпозиция (разбиение на части) сложных систем с целью последующей реализации в виде отдельных небольших (до 40 - 50 операторов) подпрограмм. С появлением других принципов декомпозиции (объектного, логического и т.д.) данный способ получил название _процедурной декомпозиции_.
Э. Дейкстра предложил строить программу как композицию из нескольких типов управляющих конструкций (структур), которые позволяют повысить понимаемость логики работы программы. Программирование с использованием только таких конструкций назвали __структурным__.
В отличие от используемого ранее процедурного подхода к декомпозиции, структурный
подход требовал представления задачи в виде иерархии подзадач простейшей структуры.
Проектирование, таким образом, осуществлялось «сверху вниз» и подразумевало реализацию общей идеи, обеспечивая проработку интерфейсов подпрограмм. Одновременно вводились ограничения на конструкции алгоритмов, рекомендовались формальные модели их описания, а также специальный метод проектирования алгоритмов - метод пошаговой детализации.
Основными конструкциями структурного программирования являются: следование (выполнение операторов последовательно), разветвление (в зависимости от выполнения некоторого условия выполняется та или иная последовательность операторов) и повторение (многократное выполнение одинаковой последовательности операторов).
Спецификации процессов могут быть представлены в виде псевдокодов, блок-схем алгоритмов, Flow-форм, диаграмм Насси – Шнейдермана или просто краткого текстового описания. Наибольшую популярность получили схемы алгоритмов. Для изображения схем алгоритмов разработан ГОСТ 19.701–90.
Дальнейший рост сложности и размеров разрабатываемого программного обеспечения потребовал развития структурирования Данных. Как следствие этого в языках появляется возможность определения пользовательских типов данных. Одновременно усилилось стремление разграничить доступ к глобальным данным программы, чтобы уменьшить количество ошибок, возникающих при работе с глобальными данными. В результате появилась и начала развиваться технология модульного программирования.
Модульное программирование предполагает выделение групп подпрограмм, использующих одни и те же глобальные данные в отдельно компилируемые модули (библиотеки подпрограмм), например, модуль графических ресурсов, модуль подпрограмм вывода на принтер (рис. 1.5). между модулями при использовании данной технологии осуществляются через специальный интерфейс, в то время как доступ к реализации модуля (телам подпрограмм и некоторым «внутренним» переменным) запрещен. Эту технологию поддерживают современные языков Pascal и С (С-4+), языки Ада и Modula.
### Объектно-ориентированное программирование (сер. 80-х — сер. 90-х гг.)
**Объектно-ориентированное программирование** определяется как технология создания сложного программного обеспечения, основанная на представлении программы в виде совокупности **объектов**, каждый из которых является экземпляром определенного типа          (**класса**), а классы образуют иерархию с **наследованием** свойств. Взаимодействие программных объектов в такой системе осуществляется путем передачи **сообщений**.
Объектная структура программы впервые была использована в языке имитационного моделирования сложных систем Simula, появившемся еще в 60-х годах XX в. Естественный для языков моделирования способ представления программы получил развитие в другом специализированном языке моделирования - языке Smalltalk (70-е годы XX в.), а затем был использован в новых версиях универсальных языков программирования, таких, как Pascal, C++, Modula, Java.  
Основным достоинством объектно-ориентированного программирования по сравнению с модульным программированием является «более естественная» декомпозиция программного обеспечения, которая существенно облегчает его разработку. Это приводит к более полной локализации данных и интегрированию их с подпрограммами обработки, что позволяет вести практически независимую разработку отдельных частей (объектов) программы. Кроме этого, объектный подход предлагает новые способы организации программ, основанные на механизмах наследования, полиморфизма, композиции, наполнения. Эти механизмы позволяют конструировать сложные объекты из сравнительно простых. В результате существенно увеличивается показатель повторного использования кодов и появляется возможность создания библиотек классов для различных применений.  
Бурное развитие технологий программирования, основанных на объектном подходе, позволило решить многие проблемы. Так были созданы среды, поддерживающие **визуальное программирование**, например, Delphi, C++ Builder, Visual C++ и т. д. При использовании визуальной среды у программиста появляется возможность проектировать некоторую часть, например, интерфейсы будущего продукта, с применением визуальных средств добавления и настройки специальных библиотечных компонентов. Результатом визуального проектирования является заготовка будущей программы, в которую уже внесены соответствующие коды.  
Использование объектного подхода имеет много преимуществ, однако его конкретная реализация в объектно-ориентированных языках программирования, таких, как Pascal и C++, имеет существенные недостатки:
- фактически отсутствуют стандарты компоновки двоичных результатов компиляции объектов в единое целое даже в пределах одного языка программирования: компоновка объектов, полученных разными компиляторами C++ в лучшем случае проблематична, что приводит к необходимости разработки программного обеспечения с использованием средств и возможностей одного языка программирования высокого уровня и одного компилятора, а значит, требует одного языка программирования высокого уровня и одного компилятора, а значит, требует наличия исходных кодов используемых библиотек классов;
- изменение реализации одного из программных объектов, как минимум, связано с перекомпиляцией соответствующего модуля и перекомпоновкой всего программного обеспечения, использующего данный объект.

Таким образом, при использовании этих языков программирования сохраняется зависимость модулей программного обеспечения от адресов экспортируемых полей и методов, а также структур и форматов данных. Эта зависимость объективна, так как модули должны взаимодействовать между собой, обращаясь к ресурсам друг друга. Связи модулей нельзя разорвать, но можно попробовать стандартизировать их взаимодействие, на чем и основан компонентный подход к программированию.

### Компонентный подход и CASE-технологии (середина 90-х гг. XX в. — настоящее время)
**Компонентный подход** предполагает построение программного обеспечения из отдельных компонентов физически отдельно существующих частей программного обеспечения, которые взаимодействуют между собой через **стандартизованные двоичные интерфейсы**. В отличие от обычных объектов объекты-компоненты можно собрать в динамически вызываемые библиотеки или исполняемые файлы, распространять в двоичном виде (без исходных текстов) и использовать в любом языке программирования, поддерживающем соответствующую технологию. На сегодня рынок объектов стал реальностью, так в Интернете существуют узлы, предоставляющие большое количество компонентов, рекламой компонентов забиты журналы. Это позволяет программистам создавать продукты, хотя бы частично состоящие из повторно использованных частей, т.е. использовать технологию, хорошо зарекомендовавшую себя в области проектирования аппаратуры.  
Компонентный подход лежит в основе технологий, разработанных на базе **COM** (Component Object Model - компонентная модель объектов), и технологии создания распределенных приложений CORBA (Common Object Request Broker Architecture - общая архитектура с посредником обработки запросов объектов). Эти технологии используют сходные принципы и различаются лишь особенностями их реализации.  
Технология СОМ фирмы Microsoft является развитием технологии OLE I (Object Linking and Embedding - связывание и внедрение объектов), которая использовалась в ранних версиях Windows для создания составных документов. Технология СОМ определяет **общую парадигму взаимодействия программ любых типов**: библиотек, приложений, операционной системы, т. е. позволяет одной части программного обеспечения использовать функции (**службы**), предоставляемые другой, независимо от того, функционируют ли эти части в пределах одного процесса, в разных процессах на одном компьютере или на разных компьютерах. Модификация СОМ, обеспечивающая передачу вызовов между компьютерами, называется DCOM (Distributed COM – распределенная СОМ).
По технологии СОМ приложение предоставляет свои службы, используя специальные объекты - **объекты** СОМ, которые являются экземплярами **классов** СОМ. Объект СОМ так же, как обычный объект включает поля и методы, но в отличие от обычных объектов каждый объект СОМ может реализовывать несколько интерфейсов, обеспечивающих доступ к его полям и функциям. Это достигается за счет организации отдельной таблицы адресов методов для каждого интерфейса (по типу таблиц виртуальных методов). При этом интерфейс обычно объединяет несколько однотипных функций. Кроме того, классы СОМ поддерживают **наследование интерфейсов**, но не поддерживают **наследования реализации**, т. е. не наследуют код методов, хотя при необходимости объект класса-потомка может вызвать метод родителя.  
Каждый интерфейс имеет имя, начинающееся с символа «I» и глобальный уникальный идентификатор IID (Interface IDentifier). Любой объект СОМ обязательно реализует интерфейс ILJnknown (на схемах этот интерфейс всегда располагают сверху). Использование этого интерфейса позволяет получить доступ к остальным интерфейсам объекта.  
Объект всегда функционирует в составе сервера - динамической библиотеки или исполняемого файла, которые обеспечивают функционирование объекта. Различают три типа серверов:
- **внутренний сервер** - реализуется динамическими библиотеками, которые подключаются к приложению-клиенту и работают в одном с ними адресном пространстве - наиболее эффективный сервер, кроме того, он не требует специальных средств;
- **локальный сервер** - создается отдельным процессом (модулем, exe), который работает на одном компьютере с клиентом;
- **удаленный сервер** - создается процессом, который работает на другом компьютере.

Например, Microsoft Word является локальным сервером. Он включает множество объектов, которые могут использоваться другими приложениями.  
Для обращения к службам клиент должен получить указатель на соответствующий интерфейс. Перед первым обращением к объекту клиент посылает запрос к библиотеке СОМ, хранящей информацию обо всех, зарегистрированных в системе классах СОМ объектов, и передает ей имя класса, идентификатор интерфейса и тип сервера. Библиотека запускает необходимый сервер, создает требуемые объекты и возвращает указатели на объекты и интерфейсы. Получив указатели, клиент может вызывать необходимые функции объекта.  
Взаимодействие клиента и сервера обеспечивается базовыми механизмами СОМ или DCOM, поэтому клиенту безразлично местонахождение объекта. При использовании локальных и удаленных серверов в адресном пространстве клиента создается **proxy-объект** - заместитель объекта СОМ, а в адресном пространстве сервера СОМ - заглушка, соответствующая клиенту. Получив задание от клиента, заместитель упаковывает его параметры и, используя службы операционной системы, передает вызов заглушке. Заглушка распаковывает задание и передает его объекту СОМ. Результат возвращается клиенту в обратном порядке.  
На базе технологии СОМ и ее распределенной версии DCOM были разработаны компонентные технологии, решающие различные задачи разработки программного обеспечения.  
**OLE-automation** или просто **Automation** (автоматизация) - технология создания программируемых приложений, обеспечивающая программируемый доступ к внутренним службам этих приложений. Вводит понятие **диспинтерфейса** (dispinterface) - специального интерфейса, облегчающего вызов функций объекта. Эту технологию поддерживает, например, Microsoft Excel, предоставляя другим приложениям свои службы.  
**ActiveX** - технология, построенная на базе OLE-automation, предназначена для создания программного обеспечения как сосредоточенного на одном компьютере, так и распределенного в сети. Предполагает использование визуального программирования для создания компонентов - элементов управления ActiveX. Полученные таким образом элементы управления можно устанавливать на компьютер дистанционно с удаленного сервера, причем устанавливаемый код зависит от используемой операционной системы. Это позволяет применять элементы управления ActiveX в клиентских частях приложений Интернет.  
Основными преимуществами технологии ActiveX, обеспечивающими ей широкое распространение, являются:
- быстрое написание программного кода - поскольку все действия, связанные с организацией взаимодействия сервера и клиента берет на программное обеспечение СОМ, программирование сетевых приложений становится похожим на программирование для отдельного компьютера;
- открытость и мобильность - спецификации технологии недавно были переданы в Open Group как основа открытого стандарта;
- возможность написания приложений с использованием знакомых средств разработки, например, Visual Basic, Visual C++, Borland Delphi, Borland C++ и любых средств разработки на Java;
- большое количество уже существующих бесплатных программных элементов ActiveX (к тому же, практически любой программный компонент OLE совместим с технологиями ActiveX и может применяться без модификаций в сетевых приложениях);
- стандартность - технология ActiveX основана на широко используемых стандартах Internet (TCP/IP, HTML, Java), с одной стороны, и стандартах, введенных в свое время Microsoft и необходимых для сохранения совместимости (COM, OLE).

**MTS** (Microsoft Transaction Server - сервер управления транзакциями) - технология, обеспечивающая безопасность и стабильную работу распределенных приложений при больших объемах передаваемых данных.  
**MIDAS** (Multitier Distributed Application Server - сервер многозвенных распределенных приложений) - технология, организующая доступ к данным разных компьютеров с учетом балансировки нагрузки сети.  
Все указанные технологии реализуют компонентный подход, заложенный в СОМ. Так, с точки зрения СОМ элемент управления ActiveX - внутренний сервер, поддерживающий технологию OLE-automation. Для программиста же элемент ActiveX - «черный ящик», обладающий свойствами, методами и событиями, который можно использовать как строительный блок при создании приложений.  
Технология **CORBA**, разработанная группой компаний ОМС (Object Management Group - группа внедрения объектной технологии программирования), реализует подход, аналогичный СОМ, на базе объектов и интерфейсов CORBA. Программное ядро CORBA реализовано для всех основных аппаратных и программных платформ и потому эту технологию можно использовать для создания распределенного программного обеспечения в гетерогенной (разнородной) вычислительной среде. Организация взаимодействия между объектами клиента и сервера в CORBA осуществляется с помощью специального посредника, названного VisiBroker, и другого специализированного программного обеспечения.  
Отличительной особенностью современного этапа развития технологии программирования, кроме изменения подхода, является создание и внедрение автоматизированных технологий разработки и сопровождения программного обеспечения, которые были названы CASE-технологиями (Computer-Aided Software/System Engineering - разработка программного обеспечения/программных систем с использованием компьютерной поддержки). Без средств автоматизации разработка достаточно сложного программного обеспечения на настоящий момент становится трудно осуществимой: память человека уже не в состоянии фиксировать все детали, которые необходимо учитывать при разработке программного обеспечения. На сегодня существуют CASE-технологии, поддерживающие как структурный, так и объектный (в том числе и компонентный) подходы к программированию.  
Появление нового подхода не означает, что отныне все программное обеспечение будет создаваться из программных компонентов, но анализ существующих проблем разработки сложного программного обеспечения показывает, что он будет применяться достаточно широко.


---
## __Программные средства как сложные системы: особенности сложных систем, проблемы определения единого обобщенного критерия эффективности, требования к нему, понятие устойчивости программного средства.__

Большинство современных программных систем объективно очень сложны. Эта сложность обуславливается многими причинами, главной из которых является **логическая сложность решаемых ими задач**.  
Пока вычислительных установок было мало, и их возможности были ограничены, ЭВМ применяли в очень узких областях науки и техники, причем, в первую очередь, там, где решаемые задачи были хорошо детерминированы и требовали значительных вычислений. В наше время, когда созданы мощные компьютерные сети, появилась возможность переложить на них решение сложных ресурсоемких задач, о компьютеризации которых раньше никто, и не думал. Сейчас в процесс компьютеризации вовлекаются совершенно новые предметные области, а для уже освоенных областей усложняются уже сложившиеся постановки задач.  
Дополнительными факторами, увеличивающими сложность разработки программных систем, являются:
- **Cложность формального определения требований к программным системам**: обусловливается двумя факторами. Во-первых, при определении требований необходимо учесть большое количество различных факторов. Во-вторых, разработчики программных систем не являются специалистами в автоматизируемых предметных областях, а специалисты в предметной области, как правило, не могут сформулировать проблему в нужном ракурсе.
- **Отсутствие удовлетворительных средств описания поведения дискретных систем с большим числом состояний при недетерминированной последовательности входных воздействий**: в процессе создания программных систем используют языки сравнительно низкого уровня. Это приводит к ранней детализации операций в процессе создания программного обеспечения и увеличивает объем описаний разрабатываемых продуктов, который, как правило, превышает сотни тысяч операторов языка программирования. Средств же позволяющих детально описывать **поведение** сложных дискретных систем на более высоком уровне, чем универсальный язык программирования, не существует.
- **Коллективная разработка**: из-за больших объемов проектов разработка программного обеспечения ведется коллективом специалистов. Работая в коллективе, отдельные специалисты должны взаимодействовать друг с другом, обеспечивая целостность проекта, что при отсутствии удовлетворительных средств описания поведения сложных систем, упоминавшемся выше, достаточно сложно. Причем, чем больше коллектив разработчиков, тем сложнее организовать процесс работы
- **Необходимость увеличения степени повторяемости кодов**: на сложность разрабатываемого программного продукта влияет и то, что для увеличения производительности труда компании стремятся к созданию библиотек компонентов, которые можно было бы использовать в дальнейших разработках. Однако в этом случае компоненты приходится делать более универсальными, что в конечном итоге увеличивает сложность разработки.

Вместе взятые, эти факторы существенно увеличивают сложность процесса разработки. Однако очевидно, что все они напрямую связаны со сложностью объекта разработки - программной системы.
## __Особенности функционирования сложных программных средств: работа в реальном времени, многообразие функций, надежность функционирования.__

## Проблемы проектирования сложных программных средств: рациональное структурное построение, технология разработки, стандартизация; блочно-иерархический подход.

## Жизненный цикл программного обеспечения, процессы жизненного цикла, связь между процессами.

## Основные процессы жизненного цикла: приобретение, поставка, разработка, эксплуатация, сопровождение.

## Вспомогательные процессы жизненного цикла: документирование, управление конфигурацией, обеспечение качества, верификация, аттестация, совместная оценка, аудит, разрешение проблем.

## Организационные процессы жизненного цикла: управление, создание инфраструктуры, усовершенствование, обучение.

## Модели жизненного цикла: поэтапная, каскадная, спиральная, переиспользования и реверсивной инженерии.

## Стадии жизненного цикла: формирование требований, проектирование, реализация, тестирование, внедрение, эксплуатация и сопровождение, снятие с эксплуатации. Взаимосвязь между стадиями и процессами жизненного цикла, матрица фазы-функции.

## Способ быстрой разработки приложений (RAD): условия применения, стадии жизненного цикла, достоинства и недостатки.

## Метод и технология проектирования программного обеспечения, требования к технологии, формализация и автоматизация стадий и этапов жизненного цикла, стандартизация процесса проектирования и разработки: стандарт проектирования, стандарт оформления проектной документации, стандарт интерфейса пользователя, государственные стандарты, стандарты предприятия. Эволюция методов и средств программной инженерии.

## Эффективность технологии проектирования программного обеспечения: критерии оценки технологии проектирования – функциональные, конструктивные, основные затраты в жизненном цикле, распределение затрат на разработку, длительность разработки программного обеспечения.

## Оценка качества процессов создания программного обеспечения: международные стандарты серии ISO 9000, CMM, SPICE.

## Качество программного обеспечения, управление качеством, общие характеристики качества программного обеспечения: функциональность, надежность, удобство использования, эффективность, сопровождаемость, мобильность; критерии качества, ранжированные по фазам жизненного цикла, метрики характеристик программного обеспечения.

## Понятийный аппарат метрической теории программ – принципы количественного анализа качества объектов с расплывчатыми свойствами.

## Модель и метрики оценки сложности Боэма.

## Модель и метрики оценки сложности Холстэда.

## Модель и метрики оценки сложности Мак-Кейба (основанные на потоковых графах).

## Модель и метрики, основанные на информационных потоках.

## Методы оценки качества программного обеспечения: анкетирование, рабочие списки, контрольные задачи, метрики. Государственные стандарты в области оценки качества программного обеспечения.

## Модули, сцепление и связность-критерии независимости модулей, библиотеки ресурсов.

## Нисходящий и восходящий подход к разработке программного обеспечения, средства описания структурных алгоритмов: базовые и дополнительные алгоритмические структуры, псевдокоды, Flow-формы, диаграммы Насси-Шнейдермана.

## Программирование с защитой от ошибок: проверка выполнения операций, контроль промежуточных результатов, снижение погрешностей результатов, обработка исключений; сквозной структурный контроль.

## Разработка и анализ требований к программному обеспечению: определение целей проектируемого программного обеспечения, определение целей управления проектом; техническое задание и спецификации программного обеспечения; функциональные и нефункциональные требования.

## Технологические требования: выбор архитектуры ПО, выбор типа пользовательского интерфейса, выбор подхода к разработке, выбор языка и среды программирования.

## Планирование процесса проектирования, виды планов: календарный, индивидуальный, сетевой график разработки и проектирования программного обеспечения.

## Структурный подход к проектированию программного обеспечения: основные принципы, лежащие в основе структурного подхода, средства описания функциональной структуры, средства описания отношения между данными, применение средств на стадиях жизненного цикла программного обеспечения.

## Спецификации ПО при структурном подходе: формальные модели, зависящие от подхода к разработке и не зависящие от подхода – диаграммы переходов состояний, математические модели предметной области.

## Метод функционального моделирования SADT: функциональная модель SADT, стандарт IDEFO; синтаксис и семантика моделей IDEFO: действия-функции; стрелки входа, управления, выхода, механизма исполнения; комбинированные стрелки, разбиение и соединение стрелок; туннели.

## Построение моделей IDEFO: диаграммы, нумерация блоков и диаграмм, границы моделирования, наименование контекстного блока; типы связей между функциями: случайная, логическая, временная, процедурная, коммуникационная, последовательная, функциональная; дерево модели, презентационные диаграммы (FEO-диаграммы).

## Метод описания процессов IDEF3: синтаксис и семантика моделей IDEF3: единица работы – действие (процесс); связи: временное предшествование, объектный поток, нечеткое отношение; соединения: «и», «или», «исключающее или»; синхронные и асинхронные соединения, парность соединений, комбинации соединений; указатели; декомпозиция действий.

## Построение моделей IDEF3: диаграммы, нумерация блоков и диаграмм, сценарий, границы моделирования, определение действий и объектов.

## Метод структурного анализа потоков данных: назначение диаграмм потоков данных (DFD); синтаксис и семантика DFD: функциональные блоки (системы и подсистемы, процессы), внешние сущности, потоки данных, хранилища данных, ветвление и объединение потоков данных.

## Построение диаграмм потоков данных: нумерация объектов, построение контекстных диаграмм, правила детализации – балансировка, нумерация; спецификация процесса, требования, предъявляемые к спецификации, структурированный естественный язык описания спецификации процессов, верификация модели DFD – проверка на полноту и согласованность.

## Структуры данных: несвязанные, с неявными связями, с явными связями; иерархические модели Джексона-Орра.

## Моделирование данных – диаграммы «сущность-связь» (ERD): сущность, связь, атрибут.

## Метод Баркера.

## Метод IDEF1.

## Структурная и функциональная схемы: структурные схемы пакетов программ, программного комплекса, программной системы; функциональная схема-схема данных, основные обозначения по ГОСТ 19.701-90.

## Проектирование структуры программного обеспечения с использованием метода пошаговой детализации: основное правило и рекомендации по применению.

## Структурные карты Константайна: назначение, типы вызов модулей-последовательный, параллельный, вызов сопрограммы; особые условия вызова-циклический, условный,  однократный; диаграммы реализации параллельного вызова и вызова сопрограммы; типы связи – по данным, по управлению.

## Проектирование структур данных: представление  данных в оперативной памяти – векторная структура, списковые структуры; представление данных во внешней памяти – способы организации данных с последовательным и прямым доступом.

## Проектирование программного обеспечения с использованием методов декомпозиции данных: метод Джексона, метод Варнье-Орра.

## Структурный подход к проектированию программного обеспечения: основные достоинства и недостатки, особенности применения, перспективы развития.