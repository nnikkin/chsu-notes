---
---
зачем мне всё это... ну это явно бесполезная хуйня, которую вспоминают только преподы в вузах
```table-of-contents
style:nestedOrderedList
```

---
<div class="page-break" style="page-break-before: always;"></div>

## __Программа, комплекс программ, программное средство, программное обеспечение, программный продукт. Концепция программного изделия: непосредственная производительная сила, промышленная технология проектирования программ, стандарты и сборочное программирование, контроль и управление качеством программ, экономика программных средств, подготовка специалистов по всем этапам жизненного цикла программ, разделение труда специалистов в проектных организациях.__

__Программой__ называют адресованный компьютеру набор инструкций, точно описывающий
последовательность действий, которые необходимо выполнить _для решения конкретной задачи._
__Комплекс программ__ — это набор взаимосвязанных программ, совместно решающих небольшой класс задач некоторой предметной области.
__Программное средство__ — это объект, состоящий из программ, процедур, правил и сопутствующих им документации и данных.
__Программное обеспечение__ — это совокупность программ системы обработки информации и программных документов, необходимых для эксплуатации этих программ
__Программный продукт (или программное изделие)__ — это комплекс взаимосвязанных программ для решения определенной проблемы (задачи) массового спроса, подготовленный к реализации как любой вид промышленной продукции. _Программная
продукция_ — это программа (программный комплекс, программная система),
которую стремятся продать на широком рынке тысячам, миллионам пользователей.

### Концепция программного изделия
Программное изделие (или программный продукт) — это результат промышленного подхода к разработке программного обеспечения. Этот подход рассматривает ПО не как результат творчества одного разработчика, а как продукт, созданный по чётким инженерным и экономическим правилам.
#### **Непосредственная производительная сила**
__Непосредственная производительная сила__ — это научные и технические знания, которые непосредственно внедряются в производство и активно используются в нем для создания материальных благ.
В современной экономике программное обеспечение перестало быть просто вспомогательным инструментом. Оно стало **прямой производительной силой**, то есть средством производства, которое непосредственно участвует в создании товаров и услуг. Автоматизация производства, логистики, финансов, аналитики — всё это примеры того, как ПО напрямую увеличивает производительность и создаёт стоимость.
#### **Промышленная технология проектирования программ**
Это переход от "кустарного" написания кода к фабричному производству. Промышленный подход включает:
- **Методологии разработки**: Использование строгих моделей, таких как Waterfall (Водопадная), Agile, Scrum, для организации процесса.
- **Автоматизация**: Применение инструментов для автоматической сборки, тестирования (CI/CD) и развёртывания программ.
- **Моделирование**: Использование языков вроде UML для проектирования архитектуры системы перед написанием кода.
#### **Стандарты и сборочное программирование**
Чтобы создавать большие и сложные системы, нужны общие правила и готовые блоки.
- **Стандарты**: Это набор правил и соглашений (например, стандарты кодирования, протоколы обмена данными вроде HTTP, стандарты безопасности), которые обеспечивают совместимость и предсказуемость.
- **Сборочное программирование**: Концепция, при которой программа не пишется с нуля, а собирается из уже существующих, проверенных компонентов, библиотек и фреймворков. Это значительно ускоряет разработку и повышает надёжность.
#### **Контроль и управление качеством программ (QA)**
Качество продукта — ключевой фактор его успеха. В промышленной разработке это не случайность, а результат целенаправленной деятельности, включающей:
- **Тестирование**: Проверка продукта на ошибки (баги) на разных уровнях (модульное, интеграционное, системное).
- **Анализ кода (Code Review)**: Проверка кода другими разработчиками для поиска ошибок и улучшения его качества.
- **Метрики качества**: Использование показателей (например, количество дефектов на тысячу строк кода) для оценки и контроля качества.
#### **Экономика программных средств**
Программный продукт — это экономический актив. Его разработка требует инвестиций, а результат должен приносить прибыль. Экономика ПО включает:
- **Оценку трудозатрат и бюджета**: Планирование ресурсов, необходимых для создания продукта.
- **Ценообразование**: Определение стоимости продукта на основе затрат, ценности для клиента и рыночной конъюнктуры (например, продажа лицензий, подписка).
- **Совокупная стоимость владения (TCO)**: Учёт не только стоимости разработки, но и затрат на поддержку, обновления и сопровождение продукта в течение его жизненного цикла.
#### **Подготовка специалистов по всем этапам жизненного цикла**
Промышленное производство ПО требует команды профессионалов с разными навыками, которые покрывают весь **жизненный цикл программы**: от идеи до вывода из эксплуатации. Это аналитики, архитекторы, разработчики, тестировщики, DevOps-инженеры, менеджеры проектов, специалисты по поддержке. Система образования и корпоративного обучения должна готовить кадры для каждой из этих ролей.
#### **Разделение труда специалистов**
Как и на любом заводе, в крупных проектах по разработке ПО существует чёткое разделение труда. Каждый специалист фокусируется на своей области:
- **Бизнес-аналитик** определяет, _что_ нужно сделать.
- **Системный архитектор** решает, _как_ это будет спроектировано в целом.
- **Разработчик (программист)** пишет код, реализуя конкретные функции.
- **Тестировщик (QA-инженер)** проверяет, _правильно ли_ всё работает.
- **Менеджер проекта** следит за сроками, бюджетом и командой.

---
<div class="page-break" style="page-break-before: always;"></div>

## __Технология программирования, основные этапы развития: «стихийное» программирование, структурное программирование, объектно-ориентированное программирование, компонентное программирование.__

__Технологией программирования__ — это (1) совокупность методов и средств, используемых в процессе разработки программного обеспечения, или (2) система методов, способов и приемов разработки и отладки программ.

___В широком смысле следует понимать технологию разработки программного средства, как совокупность абсолютно всех технологических процессов его создания – от момента зарождения идеи о данном программном средстве (ПС) до составления необходимой программной документации.___

Как любая другая технология, технология программирования представляет собой набор технологических инструкций, включающих:
- указание последовательности выполнения технологических операций;
- перечисление условий, при которых выполняется та или иная операция;
- описания самих операций, где для каждой операции определены исходные данные, результаты, а также инструкции, нормативы, стандарты, критерии, методы оценки и т. п.

### Стихийное программирование (до 60-х гг. XX в.)
До середины 1960-х гг. преимущественно использовалась неструктурированная, «стихийная» технология программирования. Структура первых простейших программ состояла собственно из программы, написанной на машинном языке (в двоичных или шестнадцатеричных кодах) и обрабатываемых ею данных.
Появление машинно-ориентированных языков (ассемблеров) позволило программистам вместо кодов использовать мнемонические обозначения кодов операций и символические имена данных. Программы стали «читаемыми».
Появление языков программирования высокого уровня (FORTRAN, ALGOL) позволило снизить уровень детализации операций. Большим достижением этих языков стала возможность использования подпрограмм. Были созданы большие библиотеки различных подпрограмм. Теперь структура программы состояла из основной программы, области глобальных данных и набора подпрограмм. Недостаток такой структуры — возрастание вероятности искажения части глобальных данных какой-либо подпрограммой при увеличении количества подпрограмм. Для сокращения таких ошибок было предложено размещать в подпрограммах локальные данные. Появилась возможность совместной разработки ПО несколькими программистами.
Использовался метод программирования «снизу—вверх», т.е. сначала разрабатывались простые подпрограммы, а затем строилась сложная программа путем их сборки. При сборке программы появлялось большое количество ошибок согласования, а при их исправлении появлялись новые ошибки. Процесс тестирования и отладки занимал 80% времени разработки ПО.
### Структурное программирование (1960—1970-е гг.)
_Структурный подход к программированию_ представляет собой совокупность рекомендуемых технологических приемов, охватывающих выполнение всех этапов разработки программного обеспечения. В основе структурного подхода лежит Декомпозиция (разбиение на части) сложных систем с целью последующей реализации в виде отдельных небольших (до 40 - 50 операторов) подпрограмм. С появлением других принципов декомпозиции (объектного, логического и т.д.) данный способ получил название _процедурной декомпозиции_.
Э. Дейкстра предложил строить программу как композицию из нескольких типов управляющих конструкций (структур), которые позволяют повысить понимаемость логики работы программы. Программирование с использованием только таких конструкций назвали __структурным__.
В отличие от используемого ранее процедурного подхода к декомпозиции, структурный
подход требовал представления задачи в виде иерархии подзадач простейшей структуры.
Проектирование, таким образом, осуществлялось «сверху вниз» и подразумевало реализацию общей идеи, обеспечивая проработку интерфейсов подпрограмм. Одновременно вводились ограничения на конструкции алгоритмов, рекомендовались формальные модели их описания, а также специальный метод проектирования алгоритмов - метод пошаговой детализации.
__Основными конструкциями структурного программирования являются__:
- следование (выполнение операторов последовательно),
- разветвление (в зависимости от выполнения некоторого условия выполняется та или иная последовательность операторов),
- повторение (многократное выполнение одинаковой последовательности операторов).
Спецификации процессов могут быть представлены в виде псевдокодов, блок-схем алгоритмов, Flow-форм, диаграмм Насси – Шнейдермана или просто краткого текстового описания. Наибольшую популярность получили схемы алгоритмов. Для изображения схем алгоритмов разработан ГОСТ 19.701–90.
Дальнейший рост сложности и размеров разрабатываемого программного обеспечения потребовал развития структурирования Данных. Как следствие этого в языках появляется возможность определения пользовательских типов данных. Одновременно усилилось стремление разграничить доступ к глобальным данным программы, чтобы уменьшить количество ошибок, возникающих при работе с глобальными данными. В результате появилась и начала развиваться технология модульного программирования.
Модульное программирование предполагает выделение групп подпрограмм, использующих одни и те же глобальные данные в отдельно компилируемые модули (библиотеки подпрограмм), например, модуль графических ресурсов, модуль подпрограмм вывода на принтер (рис. 1.5). между модулями при использовании данной технологии осуществляются через специальный интерфейс, в то время как доступ к реализации модуля (телам подпрограмм и некоторым «внутренним» переменным) запрещен. Эту технологию поддерживают современные языков Pascal и С (С-4+), языки Ада и Modula.
### Объектно-ориентированное программирование (сер. 80-х — сер. 90-х гг.)
**Объектно-ориентированное программирование** определяется как технология создания сложного программного обеспечения, основанная на представлении программы в виде совокупности **объектов**, каждый из которых является экземпляром определенного типа          (**класса**), а классы образуют иерархию с **наследованием** свойств. Взаимодействие программных объектов в такой системе осуществляется путем передачи **сообщений**.
Объектная структура программы впервые была использована в языке имитационного моделирования сложных систем Simula, появившемся еще в 60-х годах XX в. Естественный для языков моделирования способ представления программы получил развитие в другом специализированном языке моделирования - языке Smalltalk (70-е годы XX в.), а затем был использован в новых версиях универсальных языков программирования, таких, как Pascal, C++, Modula, Java.  
Основным достоинством объектно-ориентированного программирования по сравнению с модульным программированием является «более естественная» декомпозиция программного обеспечения, которая существенно облегчает его разработку. Это приводит к более полной локализации данных и интегрированию их с подпрограммами обработки, что позволяет вести практически независимую разработку отдельных частей (объектов) программы. Кроме этого, объектный подход предлагает новые способы организации программ, основанные на механизмах наследования, полиморфизма, композиции, наполнения. Эти механизмы позволяют конструировать сложные объекты из сравнительно простых. В результате существенно увеличивается показатель повторного использования кодов и появляется возможность создания библиотек классов для различных применений.  
Бурное развитие технологий программирования, основанных на объектном подходе, позволило решить многие проблемы. Так были созданы среды, поддерживающие **визуальное программирование**, например, Delphi, C++ Builder, Visual C++ и т. д. При использовании визуальной среды у программиста появляется возможность проектировать некоторую часть, например, интерфейсы будущего продукта, с применением визуальных средств добавления и настройки специальных библиотечных компонентов. Результатом визуального проектирования является заготовка будущей программы, в которую уже внесены соответствующие коды.  
Использование объектного подхода имеет много преимуществ, однако его конкретная реализация в объектно-ориентированных языках программирования, таких, как Pascal и C++, имеет существенные недостатки:
- фактически отсутствуют стандарты компоновки двоичных результатов компиляции объектов в единое целое даже в пределах одного языка программирования: компоновка объектов, полученных разными компиляторами C++ в лучшем случае проблематична, что приводит к необходимости разработки программного обеспечения с использованием средств и возможностей одного языка программирования высокого уровня и одного компилятора, а значит, требует одного языка программирования высокого уровня и одного компилятора, а значит, требует наличия исходных кодов используемых библиотек классов;
- изменение реализации одного из программных объектов, как минимум, связано с перекомпиляцией соответствующего модуля и перекомпоновкой всего программного обеспечения, использующего данный объект.

Таким образом, при использовании этих языков программирования сохраняется зависимость модулей программного обеспечения от адресов экспортируемых полей и методов, а также структур и форматов данных. Эта зависимость объективна, так как модули должны взаимодействовать между собой, обращаясь к ресурсам друг друга. Связи модулей нельзя разорвать, но можно попробовать стандартизировать их взаимодействие, на чем и основан компонентный подход к программированию.

### Компонентный подход и CASE-технологии (середина 90-х гг. XX в. — настоящее время)
**Компонентный подход** предполагает построение программного обеспечения из отдельных компонентов физически отдельно существующих частей программного обеспечения, которые взаимодействуют между собой через **стандартизованные двоичные интерфейсы**. В отличие от обычных объектов объекты-компоненты можно собрать в динамически вызываемые библиотеки или исполняемые файлы, распространять в двоичном виде (без исходных текстов) и использовать в любом языке программирования, поддерживающем соответствующую технологию.
Компонентный подход лежит в основе технологий, разработанных на базе **COM** (Component Object Model - компонентная модель объектов), и технологии создания распределенных приложений CORBA (Common Object Request Broker Architecture - общая архитектура с посредником обработки запросов объектов). Эти технологии используют сходные принципы и различаются лишь особенностями их реализации.  
Технология СОМ фирмы Microsoft является развитием технологии OLE I (Object Linking and Embedding - связывание и внедрение объектов), которая использовалась в ранних версиях Windows для создания составных документов. Технология СОМ определяет **общую парадигму взаимодействия программ любых типов**: библиотек, приложений, операционной системы, т. е. позволяет одной части программного обеспечения использовать функции (**службы**), предоставляемые другой, независимо от того, функционируют ли эти части в пределах одного процесса, в разных процессах на одном компьютере или на разных компьютерах. Модификация СОМ, обеспечивающая передачу вызовов между компьютерами, называется DCOM (Distributed COM – распределенная СОМ).
По технологии СОМ приложение предоставляет свои службы, используя специальные объекты - **объекты** СОМ, которые являются экземплярами **классов** СОМ. Объект СОМ так же, как обычный объект включает поля и методы, но в отличие от обычных объектов каждый объект СОМ может реализовывать несколько интерфейсов, обеспечивающих доступ к его полям и функциям. Это достигается за счет организации отдельной таблицы адресов методов для каждого интерфейса (по типу таблиц виртуальных методов). При этом интерфейс обычно объединяет несколько однотипных функций. Кроме того, классы СОМ поддерживают **наследование интерфейсов**, но не поддерживают **наследования реализации**, т. е. не наследуют код методов, хотя при необходимости объект класса-потомка может вызвать метод родителя.  
Каждый интерфейс имеет имя, начинающееся с символа «I» и глобальный уникальный идентификатор IID (Interface IDentifier). Любой объект СОМ обязательно реализует интерфейс IUnknown (на схемах этот интерфейс всегда располагают сверху). Использование этого интерфейса позволяет получить доступ к остальным интерфейсам объекта.  
Объект всегда функционирует в составе сервера - динамической библиотеки или исполняемого файла, которые обеспечивают функционирование объекта. Различают три типа серверов:
- **внутренний сервер** - реализуется динамическими библиотеками, которые подключаются к приложению-клиенту и работают в одном с ними адресном пространстве - наиболее эффективный сервер, кроме того, он не требует специальных средств;
- **локальный сервер** - создается отдельным процессом (модулем, exe), который работает на одном компьютере с клиентом;
- **удаленный сервер** - создается процессом, который работает на другом компьютере.
Например, Microsoft Word является локальным сервером. Он включает множество объектов, которые могут использоваться другими приложениями.  
Для обращения к службам клиент должен получить указатель на соответствующий интерфейс. Перед первым обращением к объекту клиент посылает запрос к библиотеке СОМ, хранящей информацию обо всех, зарегистрированных в системе классах СОМ объектов, и передает ей имя класса, идентификатор интерфейса и тип сервера. Библиотека запускает необходимый сервер, создает требуемые объекты и возвращает указатели на объекты и интерфейсы. Получив указатели, клиент может вызывать необходимые функции объекта.  
Взаимодействие клиента и сервера обеспечивается базовыми механизмами СОМ или DCOM, поэтому клиенту безразлично местонахождение объекта. При использовании локальных и удаленных серверов в адресном пространстве клиента создается **proxy-объект** - заместитель объекта СОМ, а в адресном пространстве сервера СОМ - заглушка, соответствующая клиенту. Получив задание от клиента, заместитель упаковывает его параметры и, используя службы операционной системы, передает вызов заглушке. Заглушка распаковывает задание и передает его объекту СОМ. Результат возвращается клиенту в обратном порядке.  
На базе технологии СОМ и ее распределенной версии DCOM были разработаны компонентные технологии, решающие различные задачи разработки программного обеспечения.  
**OLE-automation** или просто **Automation** (автоматизация) - технология создания программируемых приложений, обеспечивающая программируемый доступ к внутренним службам этих приложений. Вводит понятие **диспинтерфейса** (dispinterface) - специального интерфейса, облегчающего вызов функций объекта. Эту технологию поддерживает, например, Microsoft Excel, предоставляя другим приложениям свои службы.  
**ActiveX** - технология, построенная на базе OLE-automation, предназначена для создания программного обеспечения как сосредоточенного на одном компьютере, так и распределенного в сети. Предполагает использование визуального программирования для создания компонентов - элементов управления ActiveX. Полученные таким образом элементы управления можно устанавливать на компьютер дистанционно с удаленного сервера, причем устанавливаемый код зависит от используемой операционной системы. Это позволяет применять элементы управления ActiveX в клиентских частях приложений Интернет.  
Основными преимуществами технологии ActiveX, обеспечивающими ей широкое распространение, являются:
- быстрое написание программного кода - поскольку все действия, связанные с организацией взаимодействия сервера и клиента берет на программное обеспечение СОМ, программирование сетевых приложений становится похожим на программирование для отдельного компьютера;
- открытость и мобильность - спецификации технологии недавно были переданы в Open Group как основа открытого стандарта;
- возможность написания приложений с использованием знакомых средств разработки, например, Visual Basic, Visual C++, Borland Delphi, Borland C++ и любых средств разработки на Java;
- большое количество уже существующих бесплатных программных элементов ActiveX (к тому же, практически любой программный компонент OLE совместим с технологиями ActiveX и может применяться без модификаций в сетевых приложениях);
- стандартность - технология ActiveX основана на широко используемых стандартах Internet (TCP/IP, HTML, Java), с одной стороны, и стандартах, введенных в свое время Microsoft и необходимых для сохранения совместимости (COM, OLE).

**MTS** (Microsoft Transaction Server - сервер управления транзакциями) - технология, обеспечивающая безопасность и стабильную работу распределенных приложений при больших объемах передаваемых данных.  
**MIDAS** (Multitier Distributed Application Server - сервер многозвенных распределенных приложений) - технология, организующая доступ к данным разных компьютеров с учетом балансировки нагрузки сети.  
Все указанные технологии реализуют компонентный подход, заложенный в СОМ. Так, с точки зрения СОМ элемент управления ActiveX - внутренний сервер, поддерживающий технологию OLE-automation. Для программиста же элемент ActiveX - «черный ящик», обладающий свойствами, методами и событиями, который можно использовать как строительный блок при создании приложений.  
Технология **CORBA**, разработанная группой компаний ОМС (Object Management Group - группа внедрения объектной технологии программирования), реализует подход, аналогичный СОМ, на базе объектов и интерфейсов CORBA. Программное ядро CORBA реализовано для всех основных аппаратных и программных платформ и потому эту технологию можно использовать для создания распределенного программного обеспечения в гетерогенной (разнородной) вычислительной среде. Организация взаимодействия между объектами клиента и сервера в CORBA осуществляется с помощью специального посредника, названного VisiBroker, и другого специализированного программного обеспечения.  
Отличительной особенностью современного этапа развития технологии программирования, кроме изменения подхода, является создание и внедрение автоматизированных технологий разработки и сопровождения программного обеспечения, которые были названы CASE-технологиями (Computer-Aided Software/System Engineering - разработка программного обеспечения/программных систем с использованием компьютерной поддержки). Без средств автоматизации разработка достаточно сложного программного обеспечения на настоящий момент становится трудно осуществимой: память человека уже не в состоянии фиксировать все детали, которые необходимо учитывать при разработке программного обеспечения. На сегодня существуют CASE-технологии, поддерживающие как структурный, так и объектный (в том числе и компонентный) подходы к программированию.  
Появление нового подхода не означает, что отныне все программное обеспечение будет создаваться из программных компонентов, но анализ существующих проблем разработки сложного программного обеспечения показывает, что он будет применяться достаточно широко.

---
<div class="page-break" style="page-break-before: always;"></div>

## __Программные средства как сложные системы: особенности сложных систем, проблемы определения единого обобщенного критерия эффективности, требования к нему, понятие устойчивости программного средства.__

Большинство современных программных систем объективно очень сложны. Эта сложность обуславливается многими причинами, главной из которых является **логическая сложность решаемых ими задач**.  
Сложность разработки программного обеспечения обусловлена рядом причин:
- сложностью предметной области: в начале развития ЭВМ имели крайне ограниченные, по сравнению с нынешними машинами, возможности, и их применяли в узких областях науки и техники при решении задач, условия которых были хорошо детерминированы и формализованы. Такими ЭВМ управляли простые программные системы. Они, в основном, имеют очень ограниченную область применения и короткое время жизни. Но с развитием технологий появились компьютеры и сети, обладающие несравненно большей вычислительной мощностью. Эго дало возможность создавать сложные программные системы, которые могут решать ряд важных задач, что даст огромную выгоду, но также может привести к значительным убыткам при некорректной работе. Характерная черта таких программных систем — уровень сложности: один разработчик не в состоянии должным образом охватить все нюансы такой системы.
- трудностью управления процессом разработки,
- необходимостью обеспечить достаточную гибкость программы,
- неудовлетворительными способами описания поведения больших дискретных систем,
- и т.д.
Дополнительными факторами, увеличивающими сложность разработки программных систем, являются:
- **Cложность формального определения требований к программным системам**: во-первых, при определении требований необходимо учесть большое количество различных факторов. Во-вторых, разработчики программных систем не являются специалистами в автоматизируемых предметных областях, а специалисты в предметной области, как правило, не могут сформулировать проблему в нужном ракурсе.
- **Отсутствие удовлетворительных средств описания поведения дискретных систем с большим числом состояний при недетерминированной последовательности входных воздействий**: в процессе создания программных систем используют языки сравнительно низкого уровня. Это приводит к ранней детализации операций в процессе создания программного обеспечения и увеличивает объем описаний разрабатываемых продуктов, который, как правило, превышает сотни тысяч операторов языка программирования. Средств же позволяющих детально описывать **поведение** сложных дискретных систем на более высоком уровне, чем универсальный язык программирования, не существует.
- **Коллективная разработка**: из-за больших объемов проектов разработка программного обеспечения ведется коллективом специалистов. Работая в коллективе, отдельные специалисты должны взаимодействовать друг с другом, обеспечивая целостность проекта, что при отсутствии удовлетворительных средств описания поведения сложных систем, упоминавшемся выше, достаточно сложно. Причем, чем больше коллектив разработчиков, тем сложнее организовать процесс работы
- **Необходимость увеличения степени повторяемости кодов**: на сложность разрабатываемого программного продукта влияет и то, что для увеличения производительности труда компании стремятся к созданию библиотек компонентов, которые можно было бы использовать в дальнейших разработках. Однако в этом случае компоненты приходится делать более универсальными, что в конечном итоге увеличивает сложность разработки.
Вместе взятые, эти факторы существенно увеличивают сложность процесса разработки. Однако очевидно, что все они напрямую связаны со сложностью объекта разработки - программной системы.
__Устойчивость программного обеспечения__ – свойство осуществлять требуемое преобразование информации при сохранении выходных решений программы в пределах допусков, установленных спецификацией при воздействии на программы таких факторов неустойчивости, как ошибки операторов ЭВМ, а также не выявленных ошибок программы.

---
<div class="page-break" style="page-break-before: always;"></div>

## __Особенности функционирования сложных программных средств: работа в реальном времени, многообразие функций, надежность функционирования.__

Создание сложных систем с заданными характеристиками при ограниченных ресурсах требует проведения определенного комплекса мероприятий для достижения поставленной цели, который получил название _проект_. Целенаправленное управление _проектом_ предназначено для пропорционального распределения ресурсов между работами по созданию системы на протяжении всего цикла проектирования вплоть до внедрения системы в серийное производство.
В общем случае при проектировании необходимо создать в соответствии с принятым критерием эффективности оптимальную систему управления или обработки информации при ограничениях двух типов.
- __Первый__ тип ограничений характеризует уровень современных знаний теории и методов решения поставленных задач, принципов построения основных функциональных алгоритмов, методов структурного построения сложных систем и технологии их проектирования.
- __Второй__ тип ограничений относится в основном к техническим параметрам средств, на которых предполагается реализовать сложную систему, и к ресурсам, которые могут быть выделены на разработку и эксплуатацию системы. При проектировании ПС такими техническими ограничениями прежде всего являются параметры ЭВМ (объемы памяти, быстродействие, характеристики обмена информацией и т.д.), на которых предполагается реализовать КП. Важнейшим из ресурсов проектирования являются кадры специалистов соответствующей квалификации, которые могут быть использованы для разработки системы. Кроме того, ресурсами проектирования являются материальные и финансовые затраты, доступные как в процессе создания, так и при последующей эксплуатации системы.
### **_Работа в реальном времени_**
**_Работа в реальном времени_** с выдачей управляющей информации объектам — один из наиболее сложных режимов функционирования ПС. При этом от реального времени зависят не только моменты решения тех или иных задач, но и получаемые в результате данные. Реальное время в таких системах — важнейший параметр, определяющий выходные воздействия и функциональную связь между изменениями состояния реальных управляемых объектов и моделью их состояний в управляющей ЭВМ. Искажение значений времени может нарушить эту временную связь и привести к полному отказу системы управления. Длительность решения задач и скорость выдачи информации должны выдерживаться в соответствии с режимом работы и текущим состоянием источников информации и управляемых объектов. Это означает, что обработка информации и прогнозирование внешней ситуации должны осуществляться программами с более высокой скоростью, чем скорость реального управляемого процесса, с тем чтобы имелся определенный запас времени для принятия решений и формирования управляющих воздействий. Поэтому одной из важных для организации работы КП является проблема оперативного управления вычислительным процессом в реальном времени.
### **_Разнообразие функций ПС_**
**_Разнообразие функций ПС_** объясняется тем, что в сложных системах один и тот же КП обычно используется для управления несколькими разнотипными объектами и, кроме того, является объектом управления для других систем более высокого ранга. В то же время управляющие программы сравнительно мало изменяются в течение длительного периода эксплуатации. Изменение характеристик или состава управляемых объектов, как правило, не вызывает фундаментальной переработки программ, так как возможность таких изменений обычно учитывается в процессе разработки. Управляющие ЭВМ, ориентированные на решение определенного класса задач, проектируются или выбираются с минимальными запасами вычислительных ресурсов. Значительная определенность задач, решаемых КП, позволяет весьма полно использовать аппаратуру и определять оптимальное соотношение между отдельными параметрами реализующих ЭВМ применительно к конкретным задачам.
Кроме того, особенность работы управляющих ПС заключается в том, что за ограниченное время решается большое количество различных функциональных задач и одновременно осуществляется обмен информацией с многочисленными внешними абонентами. Вследствие асинхронности работы большинства объектов системы управления данные от них могут поступать в случайные моменты времени, последовательность которых заранее не известна. Поэтому во многих КП строгая последовательность решения задач принципиально не может быть заранее определена или задана, так как она существенным образом зависит от поступающих сообщений и длительности решения тех или иных задач. Для «развязки» во времени процессов обмена и обработки сообщений используются буферные накопители сообщений при приеме и выдаче данных.
### **_Надежность функционирования ПС_**
**_Надежность функционирования ПС_** при искажениях информации, сбоях и частичных отказах аппаратуры, которые могут возникать в процессе работы системы, — еще одна особенность ПС. Эти требования объясняются высокой степенью автоматизации процессов управления в ряде систем и особой важностью выполняемых функций. Работа в системе управления реальными объектами в большинстве случаев требует от КП надежного функционирования при длительном (иногда круглосуточном и многомесячном) непрерывном решении за данного набора задач. Так как сложность современных АСУ возрастает значительно быстрее, чем надежность используемой в них аппаратуры, то все более острой становится проблема обеспечения высокого качества выдаваемых результатов и сохранения работоспособности системы (пусть даже с худшими показателями) в условиях выхода из строя отдельных компонент аппаратуры. Для обеспечения необходимой надежности системы в КП широко применяются различные методы контроля, параллельное решение задач, а также совместная работа нескольких вычислительных машин в процессе решения единого комплекса задач управления.

---
<div class="page-break" style="page-break-before: always;"></div>

## __Проблемы проектирования сложных программных средств: рациональное структурное построение, технология разработки, стандартизация; блочно-иерархический подход__.

Рациональное структурное построение означает создание организационной структуры, которая наилучшим образом способствует эффективной работе предприятия, обеспечивая четкое распределение полномочий, ответственности и функций, а также оптимальное взаимодействие между различными подразделениями.
**_Проблема рационального структурного построения_** комплексов программ возникает следующим образом. От качества решения функциональных задач в наибольшей степени зависит эффективность всей системы управления, а выбор методов их решения определяется конкретной проектируемой системой, ее назначением и ресурсами для реализации. Однако высокая автономная функциональная эффективность управляющих программ не может быть реализована, если структура алгоритма не обеспечивает достаточно полного использования основных ресурсов ЭВМ. Таким образом, возникает проблема рационального структурного построения комплексов программных средств. Эта проблема включает в себя задачи:
-     оптимизации структуры КП как с точки зрения максимального использования ресурсов ЭВМ, так и с точки зрения эффективности их проектирования и отладки;
-     организации последовательного решения функциональных задач в реальном времени и организации оперативного взаимодействия с внешними абонентами;
-     контроля вычислительного процесса и обеспечения надежного функционирования КП при наличии различных возмущений;
-     контроля достоверности выполнения функциональных программ и адаптации КП при изменении характеристик внешних абонентов или управляющей ЭВМ;
-     обеспечения простой корректировки КП при изменении в некоторых пределах характеристик внешних абонентов и гибкой модернизируемости ПС.
Эти задачи в той или иной степени должны решаться в любых ПС и слабо связаны с функциональным назначением управляющей системы. Поэтому методы их решения могут рассматриваться отдельно от конкретного целевого назначения системы управления.

**_Проблемы технологии разработки ПС_** в значительной степени определяются их сложностью. Особенно острой проблема технологии становится в тех случаях, когда объем сложного функционально связанного КП исчисляется сотнями тысяч команд. Длительность и трудоемкость проектирования КП такого объема приближается к длительности и трудоемкости разработки сложных комплексов аппаратуры и может оказаться определяющей для затрат и сроков проектирования всей управляющей системы. В этом случае длительность их разработки определяет качество и степень автоматизации технологии проектирования ПС, а в конечном итоге и качество управляющего комплекса. Проблема технологии разработки ПС включает задачи:
-     планирования и организации всего технологического процесса проектирования КП вплоть до серийного изготовления управляющих систем, построенных на базе созданных ПС;
-     разработки математических моделей алгоритмов и других компонент управляющей системы на всех стадиях их проектирования;
-     обеспечения программирования алгоритмов, включающего задачи автоматизации самого процесса программирования, унификации типовых компонент программ и т. д.;
-     обеспечения отладки программ с различными методами их контроля, обнаружения, диагностики ошибок и методами корректировки программ;
-     обеспечения испытаний программных компонент и всего КП;
-     автоматизации изготовления документов, обеспечивающих серийное воспроизведение, контроль качества и эксплуатацию программ в составе управляющей системы.
В целом структурные и технологические проблемы проектирования ПС можно объединить в единую проблему разработки методов и автоматизированных систем для проектирования сложных /С/7. К проектированию также необходим системный комплексный подход с учетом основных особенностей и критериев эффективности, характерных для создания сложных систем. Автоматизированные системы проектирования программ могут превосходить по сложности создаваемые с их помощью ПС. Однако возможность широкого применения систем проектирования для различных ПС делает рентабельной разработку автоматизированных систем проектирования программ.

**_Проблемы стандартизации программных средств_** в значительной степени аналогичны соответствующим проблемам для любых сложных промышленных изделий. Для значительного повышения производительности труда при разработке сложных КП требуется стандартизация и комплексная автоматизация всего технологического процесса создания программ. На программу должны задаваться технические условия, обеспечивающие детальную расшифровку ее функций и возможность полной проверки функционирования при массовом тиражировании. Эти мероприятия позволят обеспечить возможность широкого применения отдельных программ в различных системах без участия их разработчиков, замену устаревших компонент без нарушения остального комплекса программ. В идеале создание сложных ПС желательно сводить к сопряжению комплектующих изделий (групп программ или модулей) при минимальной разработке нестандартных компонент для сопряжения или выполнения новых специфических функций.
Необходимо стандартизировать структуру и формы представления документов на разработанную и испытанную программу. В настоящее время такой стандарт существует и носит название «Единая система программной документации».
Следующей задачей является стандартизация структуры и правил сопряжения программ по передаче управления и по обменной информации. Должны быть унифицированы правила описания и использования переменных, правила распределения памяти, требования к обмену информацией между отдельными программами, комплексами программ и автономными системами управления. Необходима унификация методов и правил построения сложных КП, общих правил иерархического построения и взаимодействия программ, решающих единую целевую задачу. Эти мероприятия должны существенно расширить применяемость каждой разработанной программы, что непосредственно отразится на повышении производительности труда программистов. Введение унифицированных методов эффективной организации вычислительного процесса в ЭВМ, правил распределения и использования многоуровневой памяти должно существенно повысить эффективность использования производительности и памяти вычислительных машин.
Создание крупных КП объемом в десятки и сотни тысяч команд привело к необходимости статистического подхода к оценке качества функционирования таких систем. Это, в частности, означает, что нужна стандартизация методов и требований к обеспечению и измерению качества сложных ПС. Эти методы должны позволять контролировать надежность функционирования созданных КП в реальных условиях, рассчитывать и прогнозировать возможную достоверность результатов в зависимости от затрат на отладку и принятых мер для автоматического выявления искажений и исправления результатов.
Многолетние попытки создать универсальный алгоритмический язык высокого уровня, обеспечивающий удобную разработку различных программ при высоком их качестве по занимаемой памяти ЭВМ и использованию ее производительности, до настоящего времени не увенчались успехом. В пределах каждого класса систем преимущественно используется 2-3 языка, причем практически всегда некоторая часть программ разрабатывается на автокодах. Стандартизацию языков программирования целесообразно рассматривать в пределах некоторых классов систем с сохранением возможности создания программ на автокодах. При этом стандартизация правил структурного построения и взаимодействия программ должна обеспечивать возможность использования программ, записанных на языках разного уровня, по крайней мере в пределах одного класса систем. Перечисленные задачи стандартизации должны объединяться единой технологической схемой и методологией создания сложных ПС.

### **Блочно-иерархический подход к созданию сложных систем**
Большинство сложных систем как в природе, так и в технике имеет иерархическую внутреннюю структуру. Это связано с тем, что обычно связи элементов сложных систем различны как по типу, так и по силе, что и позволяет рассматривать эти системы как некоторую _совокупность взаимозависимых подсистем_. Внутренние связи элементов таких подсистем сильнее, чем связи между подсистемами.
В свою очередь, используя то же различие связей, можно каждую подсистему разделить на подсистемы и т. д. до самого нижнего «элементарного» уровня, причем выбор уровня, компоненты которого следует считать элементарными, остается за исследователем. На элементарном уровне система, как правило, состоит из немногих типов подсистем, по-разному скомбинированных и организованных. Иерархии такого типа получили название «целое-часть».
Поведение системы в целом обычно оказывается сложнее поведения отдельных частей, причем из-за более сильных внутренних связей особенности системы в основном обусловлены отношениями между ее частями, а не частями как таковыми.
В природе существует еще один вид иерархии - иерархия «простое-сложное» или иерархия развития (усложнения) систем в процессе эволюции. В этой иерархии любая функционирующая система является результатом развития более простой системы. Именно данный вид иерархии реализуется механизмом наследования объектно-ориентированного программирования.
На этих свойствах иерархических систем строится _блочно-иерархический подход_ к их исследованию или созданию. Этот подход предполагает сначала создавать части таких объектов (блоки, модули), а затем собирать из них сам объект.
Процесс разбиения сложного объекта на сравнительно независимые части получил название _декомпозиции_. При декомпозиции учитывают, что связи между отдельными частями должны быть слабее, чем связи элементов внутри частей. Кроме того, чтобы из полученных частей можно было собрать разрабатываемый объект, в процессе декомпозиции необходимо определить все виды связей частей между собой.
При создании очень сложных объектов процесс декомпозиции выполняется многократно: каждый блок, в свою очередь, декомпозируют на части пока не получают блоки, которые сравнительно легко разработать. Данный метод разработки получил название _пошаговой_ _детализации._
Существенно и то, что в процессе декомпозиции стараются выделить аналогичные блоки, которые можно было бы разрабатывать на общей основе. Таким образом, обеспечивают увеличение степени повторяемости кодов и, соответственно, снижение стоимости разработки. Результат декомпозиции обычно представляют в виде схемы _иерархии_, на нижнем уровне которой располагают сравнительно простые блоки, а на верхнем - объект, подлежащий разработке.
На каждом иерархическом уровне описание блоков выполняют с определенной степенью детализации, _абстрагируясь_ от несущественных деталей. Следовательно, для каждого уровня используют свои формы документации и свои модели, отражающие сущность процессов, выполняемых каждым блоком. Так для объекта в целом, как правило, удается сформулировать лишь самые общие требования, а блоки нижнего уровня должны быть специфицированы так, чтобы из них действительно можно было собрать работающий объект. Другими словами, _чем_ _больше блок, тем более абстрактным должно быть его описание_.
При соблюдении этого принципа разработчик сохраняет возможность осмысления проекта и, следовательно, может принимать наиболее правильные решения на каждом этапе, что называют локальной оптимизацией (в отличие от глобальной оптимизации характеристик объектов, которая для действительно сложных объектов не всегда возможна).

_Примечание._ Следует иметь в виду, что понятие сложного объекта по мере совершенствования технологий изменяется, и то, что было сложным вчера, не обязательно останется сложным завтра. Итак, в основе блочно-иерархического подхода лежат декомпозиция и иерархическое упорядочение. Важную роль играют также следующие принципы: 1) непротиворечивость — контроль согласованности элементов между собой; 2) полнота – контроль на присутствие лишних элементов; 3) формализация – строгость методического подхода; 4) повторяемость – необходимость выделения одинаковых блоков для удешевления и ускорения разработки; 5) локальная оптимизация – оптимизация в пределах уровня иерархии.

Совокупность языков моделей, постановок задач, методов описаний некоторого иерархического уровня принято называть _уровнем проектирования._
Каждый объект в процессе проектирования, как правило, приходится рассматривать с нескольких сторон. Различные взгляды на объект проектирования принято называть _аспектами_ _проектирования._
Помимо того, что использование блочно-иерархического подхода делает возможным создание сложных систем, он также:
- упрощает проверку работоспособности, как системы в целом, так и отдельных блоков;
- обеспечивает возможность модернизации систем, например, замены ненадежных блоков с сохранением их интерфейсов.
Необходимо отметить, что использование блочно-иерархического подхода применительно к программным системам стало возможным только после конкретизации общих положений подхода и внесения некоторых изменений в процесс проектирования. При этом структурный подход учитывает только свойства иерархии «целое-часть», а объектный – использует еще и свойства иерархии «простое-сложное».
<div class="page-break" style="page-break-before: always;"></div>

## __Жизненный цикл программного обеспечения, процессы жизненного цикла, связь между процессами.__
==_Жизненным циклом_ программного обеспечения называют период от момента появления идеи создания некоторого программного обеспечения до момента завершения его поддержки фирмой-разработчиком или фирмой, выполнявшей сопровождение.==
Состав процессов жизненного цикла регламентируется международным стандартом ISO/IEC 12207: 1995 «Information Technologe - Software Life Cycle Processes» («Информационные технологии - Процессы жизненного цикла программного обеспечения»). ISO – International Organization for Standardization - Международная организация по стандартизации. IЕС – International Electrotechnical Commission - Международная комиссия по электротехнике.
Этот стандарт описывает структуру жизненного цикла программного обеспечения и его процессы. ==_Процесс_ жизненного цикла определяется как совокупность взаимосвязанных действий, преобразующих некоторые входные данные в выходные. Каждый процесс характеризуется определенными задачами и методами их решения, а также исходными данными и результатами.==

### __Виды процессов__
Основные процессы:
- приобретение
- поставка
- разработка
- эксплуатация
- сопровождение
Организационные процессы:
- управление
- усовершенствование
- создание инфраструктуры
- обучение
Вспомогательные процессы
- документирование
- управление конфигурацией
- управление качеством (обеспечение качества, верификация, аттестация, совместная оценка, аудит)
- разрешение проблем


### __Cвязь между процессами__

![| 300](https://studfile.net/html/2706/628/html_tQ4oYaR7J0.e6IQ/img-oTEEf6.png)

Процессы ЖЦ ПО, регламентируемые стандартом ISO/IEC 12207, могут использоваться различными организациями в конкретных проектах самым различным образом. Тем не менее стандарт предлагает некоторый базовый набор взаимосвязей между процессами с различных точек зрения (или в различных аспектах), который показан на рис. 1.2. Такими аспектами являются:
- договорной аспект;
- аспект управления;
- аспект эксплуатации;
- инженерный аспект;
- аспект поддержки.

В _договорном аспекте_ заказчик и поставщик вступают в договорные отношения и реализуют соответственно процессы приобретения и поставки. В _аспекте управления_ заказчик, поставщик, разработчик, оператор, служба сопровождения и другие участвующие в ЖЦ ПО стороны управляют выполнением своих процессов. В _аспекте эксп__луатации_ оператор, эксплуатирующий систему, предоставляет необходимые услуги пользователям. В _инженерном аспекте_ разработчик или служба сопровождения решают соответствующие технические задачи, разрабатывая или модифицируя программные продукты. В _аспекте поддержки_ службы, реализующие вспомогательные процессы, предоставляют необходимые услуги всем остальным участникам работ. В рамках аспекта поддержки можно выделить аспект управления качеством ПО, включающий пять процессов: обеспечение качества, верификация, аттестация, совместная оценка и аудит. Организационные процессы выполняются на корпоративном уровне, или на уровне всей организации в целом, создавая базу для реализации и постоянного совершенствования остальных процессов ЖЦ ПО.

Процессы и реализующие их организации (или стороны) связаны между собой чисто функционально. При этом внутренняя структура и статус организаций никак не регламентируются. Одна и та же организация может выполнять различные роли: поставщика, разработчика и др., и, наоборот, одна и та же роль может выполняться несколькими организациями.

Взаимосвязи между процессами, описанные в стандарте, носят статический характер. Более важные динамические связи между процессами и реализующими их сторонами устанавливаются в реальных проектах.


---
<div class="page-break" style="page-break-before: always;"></div>

## __Основные процессы жизненного цикла: приобретение, поставка, разработка, эксплуатация, сопровождение.__
**_Процесс приобретения_** (acquisition process) состоит из действий и задач заказчика, приобретающего ПО. Данный процесс охватывает следующие действия:
1) инициирование приобретения;
2) подготовку заявочных предложений;
3) подготовку и корректировку договора;
4) надзор за деятельностью поставщика;
5) приемку и завершение работ.

**_Процесс поставки_** (supply process) охватывает действия и задачи, выполняемые поставщиком, который снабжает заказчика программным продуктом или услугой. Данный процесс включает следующие действия:
1) инициирование поставки;
2) подготовку ответа на заявочные предложения;
3) подготовку договора;
4) планирование;
5) выполнение и контроль;
6) проверку и оценку;
7) поставку и завершение работ.

### __Процесс разработки___
Процесс разработки (development process) в соответствии со стандартом предусматривает действия и задачи, выполняемые разработчиком, и охватывает работы по созданию программного обеспечения и его компонентов в соответствии с заданными требованиями, включая оформление проектной и эксплуатационной документации, а также подготовку материалов, необходимых для проверки работоспособности и соответствия качества программных продуктов, материалов,  необходимых для обучения персонала, и т. д.

По стандарту ==процесс разработки== включает следующие действия:
- ___подготовительную работу___ – выбор модели жизненного цикла, стандартов, методов и средств разработки, а также составление плана работ;
- ___анализ требований к системе___ – определение ее функциональных возможностей, пользовательских требований, требований к надежности и безопасности, требований к внешним интерфейсам и т. д.;
- ___проектирование архитектуры системы___ – определение состава необходимого оборудования, программного обеспечения и операций, выполняемых обслуживающим персоналом;
- ___анализ требований к программному обеспечению___ – определение функциональных возможностей, включая характеристики производительности, среды функционирования компонентов, внешних интерфейсов, спецификаций надежности и безопасности, эргономических требований, требований к используемым данным, установке, приемке, пользовательской документации, эксплуатации и сопровождению;
- ___проектирование архитектуры программного обеспечения___ – определение структуры программного обеспечения, документирование интерфейсов его компонентов, разработку предварительной версии пользовательской документации, а также требований к тестам и планам интеграции;
- ___детальное проектирование программного обеспечения___ – подробное описание компонентов программного обеспечения и интерфейсов между ними, обновление пользовательской документации, разработка и документирование требований к тестам и плана тестирования компонентов программного обеспечения, обновление плана интеграции компонентов;
- ___кодирование и тестирование программного обеспечения___ – разработку и документирование каждого компонента, а также совокупности тестовых процедур и данных для их тестирования, тестирование компонентов, обновление пользовательской документации, обновление плана интеграции программного обеспечения;
- ___интеграцию программного обеспечения___ – сборку программных компонентов в соответствии с планом интеграции и тестирование программного обеспечения на соответствие квалификационным требованиям, представляющих собой набор критериев или условий, которые необходимо выполнить, чтобы квалифицировать программный продукт, как соответствующий своим спецификациям и готовый к использованию в заданных условиях эксплуатации;
- ___квалификационное тестирование программного обеспечения___ – тестирование программного обеспечения в присутствии заказчика для демонстрации его соответствия требованиям и готовности к эксплуатации; при этом проверяется также готовность и полнота технической и пользовательской документации
- ___интеграцию системы___ – сборку всех компонентов системы, включая программное обеспечение и оборудование;
- ___квалификационное тестирование системы___ – тестирование системы на соответствие требованиям к ней и проверка оформления и полноты документации;
- ___установку программного обеспечения___ – установку программного обеспечения на оборудовании заказчика и проверку его работоспособности;
- ___приемку программного обеспечения___ – оценку результатов квалификационного тестирования программного обеспечения и системы в целом и документирование результатов оценки совместно с заказчиком, окончательную передачу программного обеспечения заказчику.

**_Процесс эксплуатации_** (operation process) охватывает действия и задачи оператора — организации, эксплуатирующей систему. Данный процесс включает следующие действия:
1) подготовительную работу;
2) эксплуатационное тестирование;
3) эксплуатацию системы;
4) поддержку пользователей.

**_Процесс сопровождения (maintenance process)_** предусматривает действия и задачи, выполняемые сопровождающей организацией (службой сопровождения). Данный процесс активизируется при изменениях (модификациях) программного продукта и соответствующей документации, вызванных возникшими проблемами или потребностями в модернизации либо адаптации ПО. В соответствии со стандартом IEE-90 под _сопровождением_ понимается внесение изменений в ПО в целях исправления ошибок, повышения производительности или адаптации к изменившимся условиям работы или требованиям. Изменения, вносимые в существующее ПО, не должны нарушать его целостности. Процесс сопровождения включает перенос ПО в другую среду (миграцию) и заканчивается снятием ПО с эксплуатации.
Процесс сопровождения охватывает следующие действия:
1) подготовительную работу;
2) анализ проблем и запросов на модификацию ПО;
3) модификацию ПО;
4) проверку и приемку;
5) перенос ПО в другую среду;
6) снятие ПО с эксплуатации.

---
<div class="page-break" style="page-break-before: always;"></div>

## __Вспомогательные процессы жизненного цикла: документирование, управление конфигурацией, обеспечение качества, верификация, аттестация, совместная оценка, аудит, разрешение проблем.__
**Процесс документирования** предусматривает формализованное описание информации, созданной в течение ЖЦ ПО. Данный процесс состоит из набора действий, с помощью которых планируют, проектируют, разрабатывают, выпускают, редактируют, распространяют и сопровождают документы, необходимые для всех заинтересованных лиц, таких, как руководство, технические специалисты и пользователи системы.
Процесс документирования включает следующие действия:
1) подготовительную работу;
2) проектирование и разработку;
3) выпуск документации;
4) сопровождение.

**Процесс управления конфигурацией** предполагает применение административных и технических процедур на всем протяжении ЖЦ ПО для определения состояния компонентов ПО в системе, управления модификациями ПО, описания и подготовки отчетов о состоянии компонентов ПО и запросов на модификацию, обеспечения полноты, совместимости и корректности компонентов ПО, управления хранением и поставкой ПО. Управление конфигурацией позволяет организовать, систематически учитывать и контролировать внесение изменений в ПО на всех стадиях ЖЦ.
Процесс управления конфигурацией включает следующие действия:
1) подготовительную работу;
2) идентификацию конфигурации;
3) контроль за конфигурацией;
4) учет состояния конфигурации;
5) оценку конфигурации;
6) управление выпуском и поставку.

**Процесс обеспечения качества** обеспечивает соответствующие гарантии того, что ПО и процессы его ЖЦ соответствуют заданным требованиям и утвержденным планам.  Под качеством ПО понимается совокупность свойств, которые характеризуют способность ПО удовлетворять заданным требованиям. Для получения достоверных оценок создаваемого ПО процесс обеспечения его качества должен происходить независимо от субъектов, непосредственно связанных с разработкой ПО. При этом могут использоваться результаты других вспомогательных процессов, таких, как верификация, аттестация, совместная оценка, аудит и разрешение проблем.
Процесс обеспечения качества включает следующие действия:
1) подготовительную работу;
2) обеспечение качества продукта;
3) обеспечение качества процесса;
4) обеспечение прочих показателей качества системы.

**Процесс верификации** состоит в определении того, что программные продукты, являющиеся результатами некоторого действия, полностью удовлетворяют требованиям или условиям, обусловленным предшествующими действиями (верификация в узком смысле означает формальное доказательство правильности ПО). Для повышения эффективности верификация должна как можно раньше интегрироваться с использующими ее процессами (такими, как поставка, разработка, эксплуатация или сопровождение). Данный процесс может включать анализ, оценку и тестирование. Верификация может проводиться с различными степенями независимости. Степень независимости может варьироваться от выполнения верификации самим исполнителем или другим специалистом данной организации до ее выполнения специалистом другой организации с различными вариациями. Если процесс верификации осуществляется организацией, не зависящей от поставщика, разработчика, оператора или службы сопровождения, то он называется процессом независимой верификации.
Процесс верификации включает следующие действия:
1) подготовительную работу;
2) верификацию.
В процессе верификации проверяются следующие условия:
- непротиворечивость требований к системе и степень учета потребностей пользователей;
- возможности поставщика выполнить заданные требования;
- соответствие выбранных процессов ЖЦ ПО условиям договора;
- адекватность стандартов, процедур и среды разработки процессам ЖЦ ПО;
- соответствие проектных спецификаций ПО заданным требованиям;
- корректность описания в проектных спецификациях входных и выходных данных, последовательности событий, интерфейсов, логики и т.д.;
- соответствие кода проектным спецификациям и требованиям;
- тестируемость и корректность кода, его соответствие принятым стандартам кодирования;
- корректность интеграции компонентов ПО в систему;
- адекватность, полнота и непротиворечивость документации.

**Процесс аттестации** предусматривает определение полноты соответствия заданных требований и созданной системы или программного продукта их конкретному функциональному назначению. Под аттестацией обычно понимается подтверждение и оценка достоверности проведенного тестирования ПО. Аттестация должна гарантировать полное соответствие ПО спецификациям, требованиям и документации, а также возможность его безопасного и надежного применения пользователем. Аттестацию рекомендуется выполнять путем тестирования во всех возможных ситуациях и использовать при этом независимых специалистов. Аттестация может проводиться на начальных стадиях ЖЦ ПО или как часть работы по приемке ПО. Аттестация, так же как и верификация, может осуществляться с различными степенями независимости. Если процесс аттестации выполняется организацией, не зависящей от поставщика, разработчика, оператора или службы сопровождения, то он называется процессом независимой аттестации.
Процесс аттестации включает следующие действия:
1) подготовительную работу;
2) аттестацию.

**Процесс совместной оценки** предназначен для оценки состояния работ по проекту и ПО, создаваемому при выполнении данных работ (действий). Он сосредоточен в основном на контроле планирования и управления ресурсами, персоналом, аппаратурой и инструментальными средствами проекта. Оценка применяется как на уровне управления проектом, так и на уровне технической реализации проекта и проводится в течение всего срока действия договора. Данный процесс может выполняться двумя любыми сторонами, участвующими в договоре, при этом одна сторона проверяет другую.
Процесс совместной оценки включает следующие действия:
1) подготовительную работу;
2) оценку управления проектом;
3) техническую оценку.

**Процесс аудита** представляет собой определение соответствия требованиям, планам и условиям договора. Аудит может выполняться двумя любыми сторонами, участвующими в договоре, когда одна сторона проверяет другую.
Аудит – это ревизия (проверка), проводимая компетентным органом (лицом) в целях обеспечения независимой оценки степени соответствия ПО или процессов установленным требованиям. Аудит служит для установления соответствия реальных работ и отчетов требованиям, планам и контракту. Аудиторы (ревизоры) не должны иметь прямой зависимости от разработчиков ПО. Они определяют состояние работ, использование ресурсов, соответствие документации спецификациям и стандартам, корректность тестирования. Процесс аудита включает следующие действия:
1) подготовительную работу;
2) аудит.

**Процесс разрешения проблем** предусматривает анализ и решение проблем (включая обнаруженные несоответствия), независимо от их происхождения или источника, которые обнаружены в ходе разработки, эксплуатации, сопровождения или других процессов. Каждая обнаруженная проблема должна быть идентифицирована, описана, проанализирована и разрешена. Процесс разрешения проблем включает следующие действия:
1) подготовительную работу;
2) разрешение проблем.

---
<div class="page-break" style="page-break-before: always;"></div>

## __Организационные процессы жизненного цикла: управление, создание инфраструктуры, усовершенствование, обучение.__

**_Процесс управления_** состоит из действий и задач, которые могут выполняться любой стороной, управляющей своими процессами. Данная сторона (менеджер) отвечает за управление выпуском продукта, управление проектом и задачами соответствующих процессов, таких, как приобретение, поставка, разработка, эксплуатация, сопровождение и др.
Процесс управления включает следующие действия:
1) инициирование и определение области управления;
2) планирование;
3) выполнение и контроль;
4) проверку и оценку;
5) завершение.

**_Процесс создания инфраструктуры_** охватывает выбор и поддержку (сопровождение) технологии, стандартов и инструментальных средств, выбор и установку аппаратных и программных средств, используемых для разработки, эксплуатации или сопровождения ПО. Инфраструктура должна модифицироваться и сопровождаться в соответствии с изменениями требований к соответствующим процессам. Инфраструктура, в свою очередь, является одним из объектов управления конфигурацией.
Процесс создания инфраструктуры включает следующие действия:
1) подготовительную работу;
2) создание инфраструктуры;
3) сопровождение инфраструктуры.

**_Процесс усовершенствования_** предусматривает оценку, измерение, контроль и усовершенствование процессов ЖЦ ПО. Данный процесс включает следующие действия:
1) создание процесса;
2) оценку процесса;
3) усовершенствование процесса.
Усовершенствование процессов ЖЦ ПО направлено на повышение производительности труда всех участвующих в них специалистов за счет совершенствования используемой технологии, методов управления, выбора инструментальных средств и обучения персонала. Усовершенствование основано на анализе достоинств и недостатков каждого процесса. Такому анализу в большой степени способствует накопление в организации исторической, технической, экономической и иной информации по реализованным проектам.

**_Процесс обучения_** охватывает первоначальное обучение и последующее постоянное повышение квалификации персонала. Приобретение, поставка, разработка, эксплуатация и сопровождение ПО в значительной степени зависят от уровня знаний и квалификации персонала. Например, разработчики ПО должны пройти необходимое обучение методам и средствам программной инженерии. Содержание процесса обучения определяется требованиями к проекту. Оно должно учитывать необходимые ресурсы и технические средства обучения. Должны быть разработаны и представлены методические материалы, необходимые для обучения пользователей в соответствии с учебным планом.
Процесс обучения включает следующие действия:
1) подготовительную работу;
2) разработку учебных материалов;
3) реализацию плана обучения.

---
<div class="page-break" style="page-break-before: always;"></div>

## __Модели жизненного цикла: поэтапная, каскадная, спиральная, переиспользования и реверсивной инженерии.__

### **Каскадная модель**. 
Первоначально (1970-1985 годы) была предложена и использовалась _каскадная схема разработки программного обеспечения_, которая предполагала, что переход на следующую стадию осуществляется после того, как полностью будут завершены проектные операции предыдущей стадии и получены все исходные данные для следующей стадии.
Достоинствами такой схемы являются:
- получение в конце каждой стадии законченного набора проектной документации, отвечающего требованиям полноты и согласованности;
- простота планирования процесса разработки.
Именно такую схему и используют обычно при блочно-иерархическом подходе к разработке сложных _технических_ объектов, обеспечивая очень высокие параметры эффективности разработки. Однако данная схема оказалась применимой только к созданию систем, для которых в самом начале разработки удавалось точно и полно сформулировать все требования. Это уменьшало вероятность возникновения в процессе разработки проблем, связанных с принятием неудачного решения на предыдущих стадиях. На практике такие разработки встречается крайне редко.
В целом необходимость возвратов на предыдущие стадии обусловлена следующими причинами:
- неточные спецификации, уточнение которых в процессе разработки может привести к необходимости пересмотра уже принятых решений;
- изменение требований заказчика непосредственно в процессе разработки;
- быстрое моральное устаревание используемых технических и программных средств;
- отсутствие удовлетворительных средств описания разработки на стадиях постановки задачи, анализа и проектирования.
Отказ от уточнения (изменения) спецификаций приведет к тому, что законченный продукт не будет удовлетворять потребности пользователей. При отказе от учета смены оборудования и программной среды пользователь получит морально устаревший продукт. А отказ от пересмотра неудачных проектных решений приводит к ухудшению структуры программного продукта и, соответственно, усложнит, растянет по времени и удорожит процесс его создания. Реальный процесс разработки, таким образом, носит итерационный характер.

### **Поэтапная модель с промежуточным контролем.**
![[Pasted image 20250916192503.png]]
Схема, поддерживающая итерационный характер процесса разработки, была названа _схемой с промежуточным контролем_. Контроль, который выполняется по данной схеме после завершения каждого этапа, позволяет при необходимости вернуться на любой уровень и внести необходимые изменения. Основная опасность использования такой схемы связана с тем, что разработка никогда не будет завершена, постоянно находясь в состоянии уточнения и усовершенствования.

### **Спиральная модель.** 
Для преодоления перечисленных проблем в середине 80-х годов XX в, была предложена _спиральная схема_. В соответствии с данной схемой программное обеспечение создается не сразу, а итерационно с использованием метода прототипирования, базирующегося на создании прототипов. Именно появление прототипирования привело к тому, что процесс модификации программного обеспечения перестал восприниматься, как «необходимое зло», а стал восприниматься как отдельный важный процесс.
_Прототипом_ называют действующий программный продукт, реализующий отдельные функции и внешние интерфейсы разрабатываемого программного обеспечения. На первой итерации, как правило, специфицируют, проектируют, реализуют и тестируют интерфейс пользователя. На второй - добавляют некоторый ограниченный набор функций. На последующих этапах этот набор расширяют, наращивая возможности данного продукта.
Основным достоинством данной схемы является то, что, начиная с некоторой итерации, на которой обеспечена определенная функциональная полнота, продукт можно предоставлять пользователю, что позволяет:
- сократить время до появления первых версий программного продукта;
- заинтересовать большое количество пользователей, обеспечивая быстрое продвижение следующих версий продукта на рынке;
- ускорить формирование и уточнение спецификаций за счет появления практики использования продукта;
- уменьшить вероятность морального устаревания системы за время разработки.
Основной проблемой использования спиральной схемы является определение моментов перехода на следующие стадии. Для ее решения обычно ограничивают сроки прохождения каждой стадии, основываясь на экспертных оценках.

### **Модель Переиспользования (Reuse-Oriented Model)**
Эта модель жизненного цикла ставит во главу угла использование уже существующих программных компонентов. Вместо того чтобы создавать все части системы с нуля, разработчики активно ищут, адаптируют и интегрируют готовые модули, библиотеки или сервисы. Это могут быть как компоненты из предыдущих проектов компании, так и сторонние коммерческие продукты (COTS - Commercial Off-The-Shelf).
Основная идея — сократить время и стоимость разработки, а также повысить надежность за счет использования уже проверенных и отлаженных решений.

**Основные этапы:**
1. **Анализ компонентов.** На основе первоначальных требований производится поиск существующих компонентов, которые могут быть использованы в проекте.
2. **Модификация требований.** Требования к системе могут быть скорректированы в зависимости от того, какие компоненты доступны. Иногда проще немного изменить требование, чем создавать сложный компонент с нуля.
3. **Проектирование системы с учетом переиспользования.** Архитектура системы выстраивается как "каркас" для интеграции выбранных компонентов. На этом этапе проектируются только те части, для которых не нашлось готовых решений.
4. **Разработка и интеграция.** Новые компоненты разрабатываются и объединяются с уже существующими в единую систему.

**Преимущества:**
- **Сокращение времени и затрат.** Переиспользование кода значительно ускоряет разработку.
- **Повышение надежности.** Используемые компоненты, как правило, уже были протестированы в других проектах.

**Недостатки:**
- **Компромисс в требованиях.** Иногда приходится жертвовать некоторыми функциями, если доступные компоненты не полностью им соответствуют.
- **Сложность интеграции.** "Склеивание" компонентов от разных разработчиков может вызвать проблемы совместимости.


###  **Модель Реверсивной Инженерии (Reverse Engineering)**
Реверсивная инженерия (или обратная разработка) — это не самостоятельная модель жизненного цикла для создания нового ПО, а скорее **процесс**, который используется для анализа и понимания уже существующей системы. Он становится ключевым элементом в моделях **реинженерии** (re-engineering), цель которых — не создать новый продукт, а кардинально переработать и улучшить старый.

**Цели и место в жизненном цикле:**
Процесс реинженерии, включающий реверсивную инженерию, обычно выглядит так:
1. **Реверсивная инженерия (Reverse Engineering).** Исходный код или работающая программа анализируется для восстановления архитектуры, бизнес-логики и моделей данных. По сути, это движение "от кода к проекту". На этом этапе создается понимание системы.
2. **Реструктуризация (Alteration/Transformation).** На основе полученных знаний система преобразуется. Это может включать улучшение структуры кода, перенос на новый язык программирования или платформу, изменение архитектуры для повышения производительности или безопасности.
3. **Прямая инженерия (Forward Engineering).** Модернизированная система реализуется, как в обычном цикле разработки: пишется новый код, происходит тестирование и внедрение обновленной версии продукта.

**Когда это применяется?**
- Для модернизации устаревших (legacy) систем.
- При восстановлении утерянной документации.
- Для анализа вредоносного ПО.
- При переносе системы на новую технологическую платформу.

Таким образом, модель переиспользования фокусируется на сборке нового из готовых "кирпичиков", а реверсивная инженерия является отправной точкой для глубокой переработки уже существующего программного обеспечения.

---
<div class="page-break" style="page-break-before: always;"></div>

## __Стадии жизненного цикла: формирование требований, проектирование, реализация, тестирование, внедрение, эксплуатация и сопровождение, снятие с эксплуатации. Взаимосвязь между стадиями и процессами жизненного цикла, матрица фазы-функции.__

**Постановка задачи.** В процессе _постановки задачи_ четко формулируют назначение программного обеспечения и определяют основные требования к нему. Каждое требование представляет собой описание необходимого или желаемого свойства программного обеспечения.
Различают _функциональные требования_, определяющие функции, которые должно выполнять разрабатываемое программное обеспечение, и _эксплуатационные требования_, определяющие особенности его функционирования.
Требования к программному обеспечению, имеющему _прототипы_, обычно определяют по аналогии, учитывая структуру и характеристики уже существующего программного обеспечения. Для формулирования требований к программному обеспечению, не имеющему аналогов, иногда необходимо провести специальные исследования, называемые предпроектными. В процессе таких исследований определяют разрешимость задачи, возможно, разрабатывают методы ее решения (если они новые) и устанавливают наиболее существенные характеристики разрабатываемого программного обеспечения. Для выполнения предпроектных исследований, как правило, заключают договор на выполнение научно-исследовательских работ. В любом случае этап постановки задачи заканчивается разработкой _технического задания_, фиксирующего принципиальные требования, и принятием основных проектных решений.

**Анализ требований и определение спецификаций.** _Спецификациями_ называют точное формализованное описание функций и ограничений разрабатываемого программного обеспечения. Соответственно различают _функциональные_ и _эксплуатационные_ спецификации.
Совокупность спецификаций представляет собой _общую_ логическую модель проектируемого программного обеспечения.
Для получения спецификаций выполняют анализ требований технического задания, формулируют содержательную постановку задачи, выбирают математический аппарат формализации, строят модель предметной области, определяют подзадачи и выбирают или разрабатывают методы их решения. Часть спецификаций может быть определена в процессе предпроектных исследований и, соответственно, зафиксирована в техническом задании.
На этом этапе также целесообразно сформировать тесты для поиска ошибок в проектируемом программном обеспечении, обязательно указав ожидаемые результаты.

**Проектирование.** Основной задачей этого этапа является определение _подробных_ спецификаций разрабатываемого программного обеспечения. Процесс проектирования сложного программного обеспечения обычно включает:
- проектирование общей структуры - определение основных компонентов и их взаимосвязей;
- декомпозицию компонентов и построение структурных иерархий в соответствии с рекомендациями блочно-иерархического подхода;
- проектирование компонентов.

Результатом проектирования является _детальная модель_ разрабатываемого программного обеспечения вместе со спецификациями его компонентов всех уровней. Тип модели зависит от выбранного подхода (структурный, объектный или компонентный) и конкретной технологии проектирования. Однако в любом случае процесс проектирования охватывает как проектирование программ (подпрограмм) и определение взаимосвязей между ними, так и проектирование данных, с которыми взаимодействуют эти программы или подпрограммы.
Принято различать также два аспекта проектирования:
- логическое проектирование, которое включает те проектные операции, которые непосредственно не зависят от имеющихся технических и программных средств, составляющих среду функционирования будущего программного продукта;
- физическое проектирование - привязка к конкретным техническим и программным средствам среды функционирования, т. е. учет ограничений, определенных в спецификациях.

**Реализация.** Реализация представляет собой процесс поэтапного написания кодов программы на выбранном языке программирования (кодирование), их тестирование и отладку.

**Внедрение** (тестирование, опытная эксплуатация) - комплексная отладка подсистем ИС, обучение персонала, поэтапное внедрение информационной системы в эксплуатацию по подразделениям экономического объекта, оформление акта о приемо-сдаточных испытаниях ИС.  Система редко вводится полностью. Как правило, это процесс постепенный или итерационный. Ввод в эксплуатацию проходит как минимум три стадии:
- первоначальная загрузка информации;
- накопление информации;
- выход на проектную мощность (то есть собственно переход к этапу эксплуатации).
Первоначальная загрузка информации инициирует довольно узкий спектр ошибок: в основном речь идет о проблемах рассогласования данных при загрузке и о собственных ошибках загрузчиков.
В период накопления информации из информационной системы выявляется наибольшее количество ошибок, связанных с многопользовательским доступом. Вторая категория исправлений связана с тем, что пользователя не устраивает интерфейс. Здесь не всегда нужно выполнять абсолютно все пожелания пользователя, иначе процесс ввода в эксплуатацию будет бесконечным.
Выход системы на проектную мощность в хорошем варианте – это доводка мелких ошибок и редкие серьезные ошибки.

**Эксплуатация информационной системы** – сбор рекламации и статистики о функционировании ИС, обслуживание пользователей, возможно устранение незначительных ошибок и недоработок (сейчас это делается повсеместно с помощью распространения так называемых patсh-файлов), оформление требований к модернизации ИС и ее выполнение.

**Сопровождение.** Сопровождение – это процесс создания и внедрения новых версий программного продукта. Причинами выпуска новых версий могут служить:
- необходимость исправления ошибок, выявленных в процессе эксплуатации предыдущих версий;
- необходимость совершенствования предыдущих версий, например, улучшения интерфейса, расширения состава выполняемых функций или повышения его производительности;
- изменение среды функционирования, например, появление новых технических средств и/или программных продуктов, с которыми взаимодействует сопровождаемое программное обеспечение.
На этом этапе в программный продукт вносят необходимые изменения, которые так же, как в остальных случаях, могут потребовать пересмотра проектных решений, принятых на любом предыдущем этапе. С изменением модели жизненного цикла программного обеспечения роль этого этапа существенно возросла, так как продукты теперь создаются итерационно: сначала выпускается сравнительно простая версия, затем следующая с большими возможностями, затем следующая и т. д. Именно это и послужило причиной выделения этапа сопровождения в отдельный процесс жизненного цикла в соответствии с стандартом ISO/IEC 12207.
Рассматриваемый стандарт только называет и определяет процессы жизненного цикла программного обеспечения, не конкретизируя в деталях, как реализовывать или выполнять действия и задачи, включенные в эти процессы. Эти вопросы регламентируются соответствующими методами, методиками и т. п. Прежде, чем перейти к подробному рассмотрению последних, проанализируем эволюцию схем разработки программного обеспечения от момента их появления до настоящего времени.

### __Матрица фазы-функции__
Чрезвычайно важным мотивом развития моделей жизненного цикла программного обеспечения является потребность в подходящем средстве для _комплексного управления проектом_. По существу, это утверждение указывает на то, что модель должна служить основой организации взаимоотношений между разработчиками, и, таким образом, одной из ее целей является _поддержка функций_ менеджера. Это приводит к необходимости наложения на модель контрольных точек, задающих организационно-временные рамки проекта, и организационно-технических, так называемых _производственных функций_, которые выполняются при развитии проекта. Наиболее последовательно такое дополнение классической схемы реализовано в _модели Гантера_ в виде матрицы «_фазы_ — _функции_». Уже из упоминания о матрице следует, что _модель Гантера_ имеет два измерения:
- фазовое, отражающее _этапы_ выполнения проекта и сопутствующие им события;
- функциональное, показывающее, какие _производственные функции_ выполняются в ходе развития проекта, и какова их интенсивность на каждом из _этапов_.

#### Фазовое измерение
В модели Гантера отражено то, что выполнение функции на одном этапе может продолжаться на следующем. На [рис. 8.1](https://intuit.ru/studies/courses/38/38/lecture/1130?page=1#image.8.1) представлено фазовое измерение модели. Жирной чертой (с разрывом и стрелкой, обозначающей временное направление) изображен процесс разработки2. Контрольные точки и наименования событий указаны под этой чертой. Они пронумерованы. Все развитие проекта в модели привязывается к этим контрольным точкам и событиям.

![Фазовое измерение модели фазы — функции](Pasted%20image%2020250918125343.png)
**Рис. 8.1.** Фазовое измерение модели фазы — функции

В данной модели жизненный цикл распадается на следующие перекрывающие друг друга фазы (этапы):

- Этап исследования — начинается, когда необходимость разработки признана руководством проекта (контрольная точка 0), и заключается в том, что для проекта обосновываются необходимые ресурсы (контрольная точка 1) и формулируются требования к разрабатываемому изделию (контрольная точка 2).
- Анализ осуществимости — начинается на этапе исследования, когда определены исполнители проекта (контрольная точка 1), и завершается утверждением требований (контрольная точка 3). Цель этапа — определить возможность конструирования изделия с технической точки зрения (достаточно ли ресурсов, квалификации и т.п.), будет ли изделие удобно для практического использования ; решение вопросов экономической и коммерческой эффективности.
- Конструирование — начинается обычно на этапе анализа осуществимости, как только документально зафиксированы предварительные цели проекта (контрольная точка 2), и заканчивается утверждением проектных решений в виде официальной спецификации на разработку (контрольная точка 5).
- Программирование — начинается на этапе конструирования, когда становятся доступными основные спецификации на отдельные компоненты изделия (контрольная точка 4), но не ранее утверждения соглашения о требованиях (контрольная точка 3). Совмещение данной фазы с заключительным этапом конструирования обеспечивает оперативную проверку проектных решений и некоторых ключевых вопросов разработки. Цель этапа — реализация программ компонентов с последующей сборкой изделия. Он завершается, когда разработчики заканчивают документирование, отладку и компоновку и передают изделие службе, выполняющей независимую оценку результатов работы (независимые испытания начались — контрольная точка 7).
- Оценка — является буферной зоной между началом испытаний и практическим использованием изделия. Этап начинается, как только проведены внутренние (силами разработчиков) испытания изделия (контрольная точка 6) и заканчивается, когда подтверждается готовность изделия к эксплуатации (контрольная точка 9).
- Использование — начинается ближе к концу этапа оценки, когда готовность изделия к эксплуатации проверена и может организовываться передача изделия на распространение (контрольная точка 8). Этап продолжается, пока изделие находится в действии и интенсивно эксплуатируется. Он связан с внедрением, обучением, настройкой и сопровождением, возможно, с модернизацией изделия. Этап заканчивается, когда разработчики прекращают систематическую деятельность по сопровождению и поддержке данного программного изделия (контрольная точка 10).

#### Функциональное измерение

На протяжении фаз жизненного цикла разработчики выполняют различные организационные и производственные функции, которые естественным образом группируются в классы родственных функций. Некоторые из этих функций для того или иного сотрудника являются технологическими, т.е. имеют четкий регламент выполнения (см. лекцию 1), другие, напротив, требуют разъяснения для выполнения. Здесь это не принципиально, но с точки зрения моделирования жизненного цикла важно следующее:

- классы родственных функций можно считать выполняемыми в течение всего хода развития проекта;
- содержание (цели) функции на различных этапах претерпевает изменение;
- интенсивность функции (в частности, потребности в ресурсах, необходимых для выполнения) меняется как при переходе от этапа к этапу, так и в рамках работ одного этапа.

Эти положения требуют отражения при моделировании жизненного цикла.

Состав функций и их интенсивность зависят от специфики проекта и команды, его выполняющей. Понятие интенсивности функции принципиально неотделимо от стратегии, принимаемой для каждой функции и в каждом специфическом случае ведения проекта. Как варианты возможного расчета интенсивности можно указать на трудозатраты на выполнение функции, удельные трудозатраты, трудозатраты с поправками учета квалификационных требований, кадровой потребности и др. Для менеджмента проекта может оказаться важным другой измеримый показатель выполнения функции, нежели какая-либо трактовка интенсивности. В качестве примера укажем на также неопределяемый показатель важности работ, связанных с выполнением функции. Если не измерять, но удается хотя бы оценивать важность, то этот показатель вполне может характеризовать развитие проекта с некоторой стороны. Наконец, ничто не мешает пользоваться разными показателями одновременно. Оставаясь в обсуждении на позициях неконкретизированности проекта, мы, следуя Гантеру, далее говорим об интенсивности, а для читателя оставляем возможность произвольно выбрать какой бы то ни было ее показатель.

Постулируется, что схема привязки функций к этапам должна сохраняться для всех видов проектов и коллективов.

Исходя из этих предпосылок, Гантер строит второе измерение своей модели. Он говорит о следующем наборе функций (если угодно — классов функций ).

- Планирование — функция, которая должна выполняться с самого начала и до конца развития любого проекта. О содержании того, что должно планироваться на каждом из этапов, можно судить по наименованиям контрольных точек. Конкретные методы планирования определяются концепциями, принимаемыми для данного проекта. Различаются стратегическое и текущее планирование, и оба вида непосредственно относятся к деятельности менеджера проекта.
- Разработка. Как и планирование, эта функция пронизывает весь проект. Содержание ее, т.е. то, что нужно разрабатывать, меняется, но в целом его можно охарактеризовать как получение рабочего продукта этапа. По-видимому, для оценки разработки показателей интенсивности недостаточно, и нужно привлекать сведения о соответствии целям (связь с планированием ), о расходовании ресурсов и др.
- Обслуживание — функция, обеспечивающая максимально комфортную обстановку выполнения некоторой деятельности. Обслуживаемые виды деятельности меняются при переходе от одного этапа к другому, а могут распространяться и на несколько этапов. Таким образом, по интенсивности обслуживания можно косвенно судить о качестве организации работ проекта. Особенностью любого обслуживания является то, что в нем участвуют как минимум два субъекта: обслуживаемый и обслуживающий. Поэтому говорить об обслуживании до того момента, когда в проекте начнут действовать исполнители, не приходится (иными словами, должно быть если не принято, то хотя бы обосновано намерение выполнять проект).
- Выпуск документации. Документация в проекте включает в себя не только техническое описание системы. Она рассматривается как полноправный вид рабочих продуктов, сопровождающий другие рабочие продукты: программы, диаграммы моделей системы и прочее. Первый рабочий продукт в проекте — утвержденные требования. И именно он первым оформляется как документ. Поэтому до утверждения требований говорить о выпуске документации как о выполняемой производственной функции не приходится. Вместе с тем начиная с этого момента интенсивность деятельности по выпуску документации растет и достигает своего максимума на этапе программирования перед этапом оценки. Далее интенсивность падает и незначительно растет к концу этапа оценки, когда приходится исправлять обнаруженные ошибки в документах, предоставляемых пользователям. И здесь видно, что содержание функции меняется даже в пределах одного этапа: это не одно и то же — создавать техническое описание и готовить руководство по эксплуатации.
- Испытания. Испытывать приходится все рабочие продукты проекта. О вариантности содержания этой функции можно судить по целям испытательных работ: подтверждения, обзоры, верификация, тестирование, аттестация и переаттестация (см. обсуждение каскадной модели в лекции 7). Поскольку испытывать можно лишь то, что готово для испытания, активизация функции начинается тогда, когда первичные требования к проекту сформулированы и нуждаются в проверке.
- Поддержка использования рабочих продуктов — это функция, выполнение которой необходимо в связи с передачей продукта в эксплуатацию. Содержание ее связано с обучением и созданием необходимой для использования продуктов инфраструктуры. Пользователями результатов анализа сначала являются разработчики архитектуры, а затем другие разработчики. Пользователи результатов конструирования — программисты, а затем другие заинтересованные лица. По этой схеме организуется эксплуатация всех рабочих продуктов, в том числе и поставляемых программных продуктов. Всякий раз требуется свой содержательный уровень поддержки.
- Сопровождение по Гантеру отличается от поддержки тем, что оно организуется для внешнего использования продуктов. Оно предполагает организацию поддержки и на этой основе выстраивает мероприятия, нацеленные на активную обратную связь с пользователями, чтобы можно было реагировать на их отклики, в том числе на изменение требований к продукту. Другой мотивировкой выделения сопровождения как особой функции является то, что для этих видов работ чаще всего приходится выделять специальные кадровые ресурсы, в частности со своей ролевой структурой, которая не сводится к структуре проектной группы.

![Матрица фазы—функции модели Гантера](Pasted%20image%2020250918125532.png)
 **Рис. 8.2.** Матрица фазы—функции модели Гантера

Для модели особенно важно, что приведенные и, возможно, другие функции **совмещаются при реализации проекта**, на базе чего строится функциональное измерение модели, наложение которого на фазовое измерение дает изображение матрицы фаз–функций в целом (см. [рис. 8.2](https://intuit.ru/studies/courses/38/38/lecture/1130?page=2#image.8.2), на котором интенсивность выполняемых функций отражается густотой закраски клеток матрицы).

Как уже говорилось, состав производственных функций и их интенсивность могут меняться от проекта к проекту в зависимости от его особенностей, от того, что руководство проекта считает главным или второстепенным. К примеру, если исходная квалификация коллектива не очень высока, в список функций может быть добавлено обучение персонала. Иногда бывает важно разграничить планирование и контроль (по Гантеру контрольные функции явно не выделяются). При объектно-ориентированном проектировании роль моделирования возрастает настолько, что его целесообразно перевести из разряда методов проектирования в явно выделенную функцию, о чем речь впереди.

Модель учитывает соотношение производственных функций и фаз жизненного цикла, чем она выгодно отличается от простых (или ограниченных?) рассмотренных ранее "идеальных" моделей. По-видимому, простота-ограниченность "идеальных" моделей есть следствие отождествления выделяемых этапов с производственной функцией, преобладающей при их выполнении. В то же время задача отражения итеративности в модели Гантера в явном виде не предусматривается. Хотя само по себе перекрытие смежных фаз проекта и выпуск соответствующей событиям документации есть путь к минимизации возвратов к выполненным этапам, более содержательные средства описания итераций в модель не закладываются.

---
<div class="page-break" style="page-break-before: always;"></div>

## __Способ быстрой разработки приложений (RAD): условия применения, стадии жизненного цикла, достоинства и недостатки.__
~~Разработка спиральной модели жизненного цикла программного обеспечения и CASE- технологий позволили сформулировать условия, выполнение которых сокращает сроки создания программного обеспечения.~~
Современная технологии проектирования, разработки и сопровождения программного обеспечения, должна отвечать следующим требованиям:
- поддержка полного жизненного цикла программного обеспечения;
- гарантированное достижение целей разработки с заданным качеством и в установленное время;
- возможность выполнения крупных проектов в виде подсистем, разрабатываемых группами исполнителей ограниченной численности (3-7 человек) с последующей интеграцией составных частей, и координации ведения общего проекта;
- минимальное время получения работоспособной системы;
- возможность управления конфигурацией проекта, ведения версий проекта и автоматического выпуска проектной документации по каждой версии;
- независимость выполняемых проектных решений от средств реализации (СУБД, операционных систем, языков и систем программирования);
- поддержка комплексом согласованных CASE-средств, обеспечивающих автоматизацию процессов, выполняемых на всех стадиях жизненного цикла.

Этим требованиям отвечает __технология RAD (Быстрая разработка приложений)__. Эта технология ориентирована на максимально быстрое получение первых версий разрабатываемого программного обеспечения. Она предусматривает выполнение следующих условий:
- ведение разработки небольшими группами разработчиков (3-7 человек), каждая из которых проектирует и реализует отдельные подсистемы проекта - позволяет улучшить управляемость проекта;
- использование итерационного подхода способствует уменьшению времени получения работоспособного прототипа;
- наличие четко проработанного графика цикла, рассчитанного не более чем на три месяца, существенно увеличивает эффективность работы.

Процесс разработки при этом делится на следующие этапы: анализ и планирование требований пользователей, проектирование, реализация, внедрение.

На этапе _анализа и планирования требований_ формулируют наиболее приоритетные требования, что ограничивает масштаб проекта.
На этапе _проектирования_, используя имеющиеся CASE-средства, детально описывают процессы системы, устанавливают требования разграничения доступа к данным и определяют состав необходимой документации. При этом для наиболее сложных процессов создают частичный прототип: разрабатывают экранную форму и диалог. По результатам анализа процессов определяют количество так называемых функциональных точек и принимают решение о количестве подсистем и, соответственно, команд, участвующих в разработке.

Под _функциональной точкой_ в технологии RAD понимают любой из следующих функциональных элементов разрабатываемой системы:
- входной элемент приложения (входной документ или экранная форма);
- выходной элемент приложения (отчет, документ или экранная форма);
- запрос (пара «вопрос/ответ»);
- логический файл (совокупность записей данных, используемых внутри приложения);
- интерфейс приложения (совокупность записей данных, передаваемых другому приложению или получаемых от него).

Нормы, рассчитанные исходя из экспертных оценок, для систем со значительной повторяемостью кодов определяются следующим образом:
- менее 1 тыс. функциональных точек- 1 человек
- от 1 до 4 тыс. функциональных точек - одна команда разработчиков
- более 4 тыс. функциональных точек - одна команда на каждые 4 тыс. точек.

В соответствии с этими нормами разрабатываемую систему делят на подсистемы, слабо связанные по данным и функциям, и точно определяют интерфейсы между различными частями.

Использование CASE-средств при этом позволяет избежать неконтролируемого искажения данных при передаче информации о проекте со стадии на стадию.

Далее разработка ведется группами разработчиков, которые продолжают прорабатывать свои части системы. Действия различных групп разработчиков при этом должны быть хорошо скоординированы.

На этапе _реализации_ выполняют итеративное построение реальной системы, причем при этом для контроля над выполнением требований к создаваемой системе привлекаются будущие пользователи. Части постепенно интегрируют в систему, причем при подключении каждой части выполняют тестирование. На завершающих этапах разработки определяют необходимость создания соответствующих баз данных, которые разрабатываются и подключаются к системе. Далее формулируют требования к аппаратным средствам, устанавливают способы увеличения производительности и завершают подготовку документации по проекту.

На этапе _внедрения_ проводят обучение пользователей и осуществляют постепенный переход на новую систему, причем эксплуатация старой версии продолжается до полного внедрения новой системы.

Технология RAD хорошо зарекомендовала себя для относительно небольших проектов, разрабатываемых для конкретного заказчика. Такие системы не требуют высокого уровня планирования и жесткой дисциплины проектирования. Однако эта технология не применима для построения сложных расчетных программ, операционных систем или программ управления сложными объектами в реальном масштабе времени, т. е. программ с большим процентом уникального кода. Не годится она и в случае создания приложений, от которых зависит безопасность людей, например, систем управления самолетами или атомными электростанциями, так как технология RAD предполагает, что первые несколько версий не будут полностью работоспособны, что в данном случае полностью исключается.

---
<div class="page-break" style="page-break-before: always;"></div>

## __Метод и технология проектирования программного обеспечения, требования к технологии, формализация и автоматизация стадий и этапов жизненного цикла, стандартизация процесса проектирования и разработки: стандарт проектирования, стандарт оформления проектной документации, стандарт интерфейса пользователя, государственные стандарты, стандарты предприятия. Эволюция методов и средств программной инженерии.__

**_Основные определения (система понятий, описывающих ТС ПО)_**

_Технология создания ПО —_ упорядоченная совокупность взаимосвязанных технологических процессов в рамках ЖЦ ПО.
_Технологический процесс —_ совокупность взаимосвязанных технологических операций.
_Технологическая операция_ — основная единица работы, выполняемая определенной ролью, которая:
- подразумевает четко определенную ответственность роли;
- дает четко определенный результат (набор рабочих продуктов), базирующийся на определенных исходных данных (другом наборе рабочих продуктов);
- представляет собой единицу работы с жестко определенными границами, которые устанавливаются при планировании проекта.

_Рабочий продукт —_ информационная или материальная сущность, которая создается, модифицируется или используется в некоторой технологической операции (модель, документ, код, тест и т.п.). Рабочий продукт определяет область ответственности роли и является объектом управления конфигурацией.
_Роль —_ определение поведения и обязанностей отдельного лица или группы лиц в среде организации-разработчика ПО, осуществляющих деятельность в рамках некоторого технологического процесса и ответственных за определенные рабочие продукты.
_Руководство_ — практическое руководство по выполнению одной или совокупности технологических операций. Руководства включают методические материалы, инструкции, нормативы, стандарты и критерии оценки качества рабочих продуктов.
_Инструментальное средство (CASE-cpedcmeo) —_ программное средство, обеспечивающее автоматизированную поддержку деятельности, выполняемой в рамках технологических операций.

Основным требованием, предъявляемым к современным ТС ПО, является их соответствие стандартам и нормативным документам, связанным с процессами ЖЦ ПО и оценкой технологической зрелости организаций-разработчиков (ISO 12207, ISO 9000, СММ и др.). Согласно этим нормативам ТС ПО должна поддерживать следующие процессы:
- управление требованиями;
- анализ и проектирование ПО;
- разработка ПО;
- эксплуатация;
- сопровождение;
- документирование;
- управление конфигурацией и изменениями;
- тестирование;
- управление проектом.

**_Полнота поддержки процессов ЖЦ ПО_ должна поддерживаться** комплексом инструментальных средств (CASE-средств).

_Соответствие стандартам_ означает также, в частности, использование общепринятых, стандартных нотаций и соглашений. Для того чтобы проект мог выполняться разными коллективами разработчиков, необходимо использование стандартных методов моделирования и стандартных нотаций, которые должны быть оформлены в виде нормативов до начала процесса проектирования. Несоблюдение проектных стандартов ставит разработчиков в зависимость от фирмы — производителя данного средства, делает затруднительным формальный контроль корректности проектных решений и снижает возможности привлечения дополнительных коллективов разработчиков, смены исполнителей и отчуждения проекта, поскольку число специалистов, знакомых с данным методом (нотацией), может быть ограниченным.
Другим важным требованием является _адаптируемость к условиям применения,_ которая достигается за счет поставки технологии в электронном виде вместе с CASE-средствами и библиотеками процессов, шаблонов, методов, моделей и других компонентов, предназначенных для построения ПО того класса систем, на который ориентирована технология. Электронные технологии должны включать средства, обеспечивающие их адаптацию и развитие по результатам выполнения конкретных проектов. Процесс адаптации заключается в удалении ненужных процессов и действий ЖЦ ПО, в изменении неподходящих или в добавлении собственных процессов и действий, а также методик, стандартов и руководств.

### Определение метода и технологии

**_Метод проектирования_** ПО представляет собой организованную совокупность процессов создания ряда моделей, которые описывают различные аспекты разрабатываемой системы с использованием четко определенной нотации. На более формальном уровне метод определяется как совокупность составляющих:
- **_Концепций и теоретических основ_**. В качестве таких основ могут выступать структурный или объектно-ориентированный подход.
- **_Нотаций,_** используемых для построения моделей статической структуры и динамики поведения проектируемой системы. В качестве таких нотаций обычно используются графические диаграммы, поскольку они наиболее наглядны и просты в восприятии (диаграммы потоков данных, и диаграммы «сущность – связь» для структурного подхода, диаграммы вариантов использования, диаграммы классов и др. – для объектно-ориентированного подхода.
- **_Процедур,_** определяющих практическое применение метода (последовательность и правила построения моделей, критерии, используемые для оценки результатов).

Методы реализуются через конкретные технологии и поддерживающие их методики, стандарты и инструментальные средства, которые обеспечивают выполнение процессов ЖЦ ПО.
**_Технология проектирования_** определяется как совокупность технологических операций проектирования в их последовательности и взаимосвязи, приводящая к разработке проекта ПО.

### Требования к технологии

Современная технология проектирования должна обеспечивать:
1. Соответствие стандарту ISO/IEC 12207: 1995 (поддержка всех процессов ЖЦ ПО).
2. Гарантированное достижение целей разработки ЭИС в рамках установленного бюджета, с заданным качеством и в установленное время.
3. Возможность декомпозиции проекта на составные части, разрабатываемые группами исполнителей ограниченной численности (3-7 чел.), с последующей интеграцией составных частей.
4. Минимальное время получения работоспособного ПО ЭИС. Речь идет не о сроках готовности всей ЭИС, а о сроках реализации отдельных подсистем. Практика показывает, что даже при наличии полностью завершенного проекта внедрение ЭИС идет последовательно по отдельным подсистемам.
5. Независимость получаемых проектных решений от средств реализации ЭИС (СУБД, ОС, языков и систем программирования).
6. Поддержка комплексом согласованных CASE – средств, обеспечивающих автоматизацию процессов, выполняемых на всех стадиях ЖЦ ПО.

Реальное применение любой технологии проектирования ПО ЭИС в конкретной организации и конкретном проекте невозможно без выработки ряда стандартов (правил, соглашений), которые должны соблюдаться всеми участниками проекта. К таким стандартам относятся:
1. Стандарт проектирования.
2. Стандарт оформления проектной документации.
3. Стандарт интерфейса конечного пользователя с системой.

**_Стандарт проектирования_** должен устанавливать:
- Набор необходимых моделей (диаграмм) на каждой стадии проектирования и степень их детализации.
- Правила фиксации проектных решений на диаграммах, в том числе правила именования объектов (включая соглашения по терминологии), набор атрибутов для всех объектов и правила их заполнения на каждой стадии, правила оформления диаграмм (включая требования к форме и размерам объектов) и т.д.
- Требования к конфигурации рабочих мест разработчиков, включая настройки ОС, настройки CASE – средств и т.д.
- Механизм обеспечения совместной работы над проектом, в том числе правила интеграции подсистем проекта, правила поддержания проекта в одинаковом для всех разработчиков состоянии (регламент обмена проектной информацией, механизм фиксации общих объектов и т.д.), правила анализа проектных решений на непротиворечивость и т.д.

**_Стандарт оформления проектной документации_**. Он должен устанавливать:

- комплектность, состав и структуру документации на каждой стадии проектирования (в соответствии со стандартом ГОСТ Р ИСО 9127 – 94 «Системы обработки информации. Документация пользователя и информация на упаковке потребительских программных пакетов»);
- требования к оформлению документации (включая требования к содержанию разделов, подразделов, пунктов, таблиц и т.д.);
- правила подготовки, рассмотрения, согласования и утверждения документации с указанием предельных сроков на каждой стадии;
- требования к настройке издательской системы, используемой в качестве встроенного средства подготовки документации;
- требования к настройке CASE – средств для обеспечения подготовки документации в соответствии с установленными правилами.

**_Стандарт интерфейса конечного пользователя с системой._** Он должен регламентировать:
- Правила оформления экранов (шрифты и цветовая палитра), состав и расположение окон и элементов управления.
- Правила использования клавиатуры и мыши.
- Правила оформления текстов помощи.
- Перечень стандартных сообщений.
- Правила обработки реакций пользователя.
---
<div class="page-break" style="page-break-before: always;"></div>

## __Эффективность технологии проектирования программного обеспечения: критерии оценки технологии проектирования – функциональные, конструктивные, основные затраты в жизненном цикле, распределение затрат на разработку, длительность разработки программного обеспечения.__

Традиционно эффективными считают программы, требующие минимального времени выполнения и/или минимального объема оперативной памяти. Особые требования к эффективности ПО предъявляют при наличии ограничений (на время реакции системы, на объем оперативной памяти и т. п.). В случаях, когда обеспечение эффективности _не требует серьезных временных и трудовых затрат, а также не приводит к_ _существенному ухудшению технологических свойств,_ необходимо это требование иметь в виду.

Разумный подход к обеспечению эффективности разрабатываемого ПО состоит в том, чтобы в первую очередь оптимизировать те фрагменты программы, которые существенно влияют на характеристики эффективности. Для уменьшения времени выполнения некоторой программы в первую очередь следует проанализировать циклические фрагменты с большим количеством повторений: экономия времени выполнения одной итерации цикла будет умножена на количество итераций.

Не следует забывать и о том, что многие способы снижения временных затрат приводят к увеличению емкостных и, наоборот, уменьшение объема памяти может потребовать дополнительного времени на обработку. И тем более не следует «платить» за увеличение эффективности снижением технологичности разрабатываемого программного обеспечения. Исключения возможны лишь при очень жестких требованиях и наличии соответствующего контроля за качеством. Частично проблему эффективности программ решают за программиста компиляторы.

Средства оптимизации, используемые компиляторами, делят на две группы:
- _машинно-зависимые_, т. е. ориентированные на конкретный машинный язык, выполняют оптимизацию кодов на уровне машинных команд, например, исключение лишних пересылок, использование более эффективных команд и т. п.;
- _машинно-независимые_ выполняют оптимизацию на уровне входного языка, например, вынесение вычислений константных (независящих от индекса цикла) выражений из циклов и т. п.

Естественно, нельзя вмешаться в работу компилятора, но существует много возможностей оптимизации программы на уровне команд.

**Способы экономии памяти.** Принятие мер по экономии памяти предполагает, что в каких-то случаях эта память неэкономно использовалась. Учитывая, что анализировать имеет смысл только операции размещения данных, существенно влияющие на характеристику эффективности, следует обращать особое внимание на выделение памяти под данные структурных типов (массивов, записей, объектов и т. п.). Прежде всего при наличии ограничений на использование памяти следует выбирать алгоритмы обработки, _не требующие дублирования исходных данных структурных типов в_ _процессе обработки._ Примером могут служить алгоритмы сортировки массивов, выполняющие операцию в заданном массиве, например, хорошо известная сортировка методом «пузырька». Если в программе необходимы большие массивы, используемые ограниченное время, то их можно размещать в динамической памяти и удалять при завершении обработки. Также следует помнить, что при передаче структурных данных в подпрограмму «по значению» копии этих данных размещаются в стеке. Избежать копирования иногда удается, если передавать данные «по ссылке», но как неизменяемые (описанные const). В последнем случае в стеке размещается только адрес данных.

**Способы уменьшения времени выполнения. Д**ля уменьшения времени выполнения в первую очередь необходимо анализировать циклические участки программы с большим количеством повторений. При их написании необходимо по возможности:

- выносить вычисление константных, т. е. не зависящих от параметров цикла, выражений из циклов;
- избегать «длинных» операций умножения и деления, заменяя их сложением, вычитанием и сдвигами;
- минимизировать преобразования типов в выражениях;
- оптимизировать запись условных выражений - исключать лишние проверки;
- исключать многократные обращения к элементам массивов по индексам (особенно многомерных, так как при вычислении адреса элемента используются операции умножения на значение индексов) - первый раз прочитав из памяти элемент массива, следует запомнить его в скалярной переменной и использовать в нужных местах;
- избегать использования различных типов в выражении и т. п.

---
<div class="page-break" style="page-break-before: always;"></div>

## __Оценка качества процессов создания программного обеспечения: международные стандарты серии ISO 9000, CMM, SPICE.__

На настоящий момент существует несколько стандартов, связанных с оценкой качества процессов создания ПО, которое обеспечивает организация-разработчик. К наиболее известным относят:
1. международные стандарты серии ISO 9000 (ISO 9000 - ISO 9004);
2. СММ - Capability Maturity Model - модель зрелости (совершенствования) процессов создания программного обеспечения, предложенная SEI (Software Engineering Institute – институт программирования при университете Карнеги-Меллон);
3. рабочая версия международного стандарта ISO/IEC 15504: эта версия более известна под названием SPICE - (определение возможностей и улучшение процесса создания программного обеспечения).

**Серия стандартов ISO 9000.** В серии ISO 9000 сформулированы необходимые условия для достижения некоторого минимального уровня организации процесса, но не дает никаких рекомендаций по дальнейшему совершенствованию процессов.

**СММ.** Представляет собой совокупность критериев оценки зрелости организации-разработчика и рецептов улучшения существующих процессов. Изначально СММ разрабатывалась и развивалась как методика, позволяющая крупным правительственным организациям США выбирать наилучших поставщиков программного обеспечения.
СММ определяет пять уровней зрелости организаций-разработчиков, причем каждый следующий уровень включает в себя все ключевые характеристики предыдущих.

1. _Начальный уровень_ - описан в стандарте в качестве основы для сравнения со следующими уровнями. На предприятии такого уровня организации не существует стабильных условий для создания качественного ПО. Результат любого проекта целиком и полностью зависит от личных качеств менеджера и опыта программистов, причем успех в одном проекте может быть повторен только в случае назначения тех же менеджеров и программистов на следующий проект. Более того, если эти менеджеры или программисты уходят с предприятия, то резко снижается качество производимых программных продуктов. В стрессовых ситуациях процесс разработки сводится к написанию кода и его минимальному тестированию.
2. _Повторяемый уровень_ - на предприятии внедрены _технологии управления проектами_. При этом планирование и управление проектами основывается на накопленном опыте, существуют стандарты на разрабатываемое ПО (причем обеспечивается следование этим стандартам) и специальная _группа обеспечения качества_. В случае необходимости организация может взаимодействовать с субподрядчиками. В критических условиях процесс имеет тенденцию скатываться на начальный уровень.
3. _Определенный уровень_ - характеризуется тем, что стандартный процесс создания и сопровождения ПО полностью документирован (включая и разработку ПО, и управление проектами). Подразумевается, что в процессе стандартизации происходит переход на наиболее эффективные практики и технологии. Для создания и поддержания подобного стандарта в организации должна быть создана специальная группа. Наконец, обязательным условием для достижения данного уровня является наличие на предприятии программы постоянного _повышения квалификации и обучения сотрудников._ Начиная с этого уровня, организация перестает зависеть от качеств конкретных разработчиков, и процесс не имеет тенденции скатываться на уровень ниже в стрессовых ситуациях.
4. _Управляемый уровень_ - в организации устанавливаются _количественные показатели качества,_ как на программные продукты, так и на процесс в целом. Таким образом, более совершенное управление проектами достигается за счет уменьшения отклонений различных показателей проекта. При этом осмысленные вариации в производительности процесса можно отличить от случайных вариаций (шума), особенно в хорошо освоенных областях.
5. _Оптимизирующий уровень_ - характеризуется тем, что мероприятия по улучшению применяются не только к существующим процессам, но и для оценки эффективности ввода новых технологий. Основной задачей всей организации на этом уровне является _постоянное_ _улучшение_ существующих процессов. При этом улучшение процессов в идеале должно помогать предупреждать возможные ошибки или дефекты. Кроме того, должны вестись работы по уменьшению стоимости разработки программного обеспечения, например с помощью создания и повторного использования компонентов.

Сертификационная оценка соответствия всех ключевых областей проводится по 10-балльной шкале. Для успешной квалификации данной ключевой области необходимо набрать не менее 6 баллов. Оценка ключевой области осуществляется по следующим показателям:

- заинтересованность руководства в данной области, например, планируется ли практическое внедрение данной ключевой области, существует ли понимание у руководства необходимости данной области и т. д.;
- насколько широко данная область применяется в организации, например, оценке в 4 балла соответствует фрагментарное применение;
- успешность использования данной области на практике, например, оценке в 0 баллов соответствует полное отсутствие какого-либо эффекта, а оценка в 8 баллов выставляется при наличии систематического и измеримого положительного результата практически во всей организации.
В принципе, можно сертифицировать только один процесс или подразделение организации, например, подразделение разработки ПО компании.

**SPICE.** Стандарт SPICE унаследовал многие черты более ранних стандартов, в том числе ISO 9001 и СММ. Больше всего SPICE напоминает СММ. Точно так же, как и в СММ, основной задачей организации является постоянное улучшение процесса разработки ПО. Кроме того, в SPICE тоже используется схема с различными уровнями возможностей (в SPICE определено 6 различных уровней), но эти уровни применяются не только к организации в целом, но и к отдельно взятым процессам.

В основе стандарта лежит _оценка процессов_. Эта оценка выполняется путем сравнения процесса разработки ПО, существующего в данной организации, с описанной в стандарте моделью. Анализ результатов, полученных на этом этапе, помогает определить сильные и слабые стороны процесса, а также внутренние риски, присущие данному процессу. Это помогает оценить эффективность процессов, определить причины ухудшения качества и связанные с этим издержки во времени или стоимости.

Затем выполняется _определение возможностей процесса_, т. е. возможностей его улучшения. В результате в организации может появиться понимание необходимости _улучшения_ того или иного _процесса_. К этому моменту цели совершенствования процесса уже четко сформулированы и остается только техническая реализация поставленных задач. После этого весь цикл работ начинается сначала.

Следует иметь в виду, что построение «более зрелого» процесса разработки не обязательно обеспечивает создание более качественного ПО.

Использование формальных моделей и методов позволяет создавать понятные, непротиворечивые спецификации на разрабатываемое ПО. Конечно, внедрение таких методов имеет смысл, хотя оно весьма дорого и трудоемко, а возможности их применения весьма ограничены. Основная же проблема - проблема сложности разрабатываемого программного обеспечения с совершенствованием процессов разработки пока не разрешена.

---
<div class="page-break" style="page-break-before: always;"></div>

## __Качество программного обеспечения, управление качеством, общие характеристики качества программного обеспечения: функциональность, надежность, удобство использования, эффективность, сопровождаемость, мобильность; критерии качества, ранжированные по фазам жизненного цикла, метрики характеристик программного обеспечения.__

**Качество программного обеспечения** — характеристика [программного обеспечения](http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B5_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5 "Программное обеспечение") (ПО) как степени его соответствия требованиям. При этом требования могут трактоваться довольно широко, что порождает целый ряд независимых определений понятия. Чаще всего используется определение [ISO 9001](http://ru.wikipedia.org/wiki/ISO_9001 "ISO 9001"), согласно которому качество есть «степень соответствия присущих характеристик требованиям».

**Фактор качества ПО** — это нефункциональное требование к программе, которое обычно не описывается в договоре с заказчиком, но, тем не менее, является желательным требованием, повышающим качество программы.

Некоторые из факторов качества:
**Этап проектирования:**
- сложность программы
- корректность программы
- трудоемкость разработки

**Этап эксплуатации:**
- функциональная сложность
- надежность
- эффективность
- трудоемкость эксплуатации

**Этап сопровождения:**
- удобство модернизации
- мобильность
- трудоемкость изучения и модификации

__Метрика качества программ__ — система измерений качества программ. Эти измерения могут проводиться на уровне критериев качества программ или на уровне отдельных характеристик качества. В первом случае система измерений позволяет непосредственно сравнивать программы по качеству. При этом сами измерения не могут быть проведены без субъективных оценок свойств программ. Во втором случае измерения характеристик можно выполнить объективно и достоверно, но оценка качества ПО в целом будет связана с субъективной интерпретацией получаемых оценок.

В исследовании метрик ПО различают два основных направления:
* поиск метрик, характеризующих наиболее специфические свойства программ, т.е. метрик оценки самого ПО;
* использование метрик для оценки технических характеристик и факторов разработки программ, т.е. метрик оценки условий разработки программ.

По виду информации, получаемой при оценке качества ПО метрики можно разбить на три группы:
* _метрики, оценивающие отклонение от нормы характеристик исходных проектных материалов._ Они устанавливают полноту заданных технических характеристик исходного кода.
* _метрики, позволяющие прогнозировать качество разрабатываемого ПО._ Они заданы на множестве возможных вариантов решений поставленной задачи и их реализации и определяют качество ПО, которое будет достигнуто в итоге.
* _метрики, по которым принимается решение о соответствии конечного ПО заданным требованиям._ Они позволяют оценить соответствие разработки заданным требованиям.

### ОСНОВНЫЕ НАПРАВЛЕНИЯ ПРИМЕНЕНИЯ МЕТРИК

В настоящее время в мировой практике используется несколько сотен метрик программ. Существующие качественные оценки программ можно сгруппировать по шести направлениям:

* оценки топологической и информационной сложности программ;
* оценки надежности программных систем, позволяющие прогнозировать отказовые ситуации;
* оценки производительности ПО и повышения его эффективности путем выявления ошибок проектирования;
* оценки уровня языковых средств и их применения;
* оценки трудности восприятия и понимания программных текстов, ориентированные на психологические факторы, существенные для сопровождения и модификации программ;
* оценки производительности труда программистов для прогнозирования сроков разработки программ и планирования работ по созданию программных комплексов.

### МЕТРИЧЕСКИЕ ШКАЛЫ

В зависимости от характеристик и особенностей применяемых метрик им ставятся в соответствие различные измерительные шкалы.

**Номинальной шкале** соответствуют метрики, классифицирующие программы на типы по признаку наличия или отсутствия некоторой характеристики без учета градаций.
**Порядковой шкале** соответствуют метрики, позволяющие ранжировать некоторое характеристики путем сравнения с опорными значениями, т.е. измерение по этой шкале фактически определяет взаимное положение конкретных программ.
**Интервальной шкале** соответствуют метрики, которые показывают не только относительное положение программ, но и то, как далеко они отстоят друг от друга.
**Относительной шкале** соответствуют метрики, позволяющие не только расположить программы определенным образом и оценить их положение относительно друг друга, но и определить, как далеко оценки отстоят от границы, начиная с которой характеристика может быть измерена.

### МЕТРИКИ СЛОЖНОСТИ ПРОГРАММ

При оценке сложности программ, как правило, выделяют три основные группы метрик:
* __метрики размера программ__: Оценки первой группы наиболее просты и поэтому получили широкое распространение. Традиционной характеристикой размера программ является  _количество строк исходного текста_. Под строкой понимается любой оператор программы. Непосредственное измерение размера программы, несмотря на свою простоту, дает хорошие результаты. Оценка размера программы недостаточна для принятия решения о ее сложности, но вполне применима для классификации программ, существенно различающихся объемами. При уменьшении различий в объеме программ на первый план выдвигаются оценки других факторов, оказывающих влияние на сложность. Таким образом, оценка размера программы есть оценка по номинальной шкале, на основе которой определяются только категории программ без уточнения оценки для каждой категории.
* __метрики сложности потока управления программ__: Как правило, с помощью этих оценок оперируют либо плотностью управляющих переходов внутри программ, либо взаимосвязями этих переходов. И в том и в другом случае стало традиционным представление программ в виде управляющего ориентированного графа G(V,E), где V – вершины, соответствующие операторам, а E – дуги, соответствующие переходам. В дуге (U,V) – вершина V является исходной, а U – конечной. При этом U непосредственно следует V, а V непосредственно предшествует U. Если путь от V до U состоит более чем из одной дуги, тогда U следует за V, а V предшествует U. Впервые графическое представление программ было предложено Маккейбом. Основной метрикой сложности он предлагает считать цикломатическую сложность графа программы, или, как еще называют, цикломатическое число Маккейба, характеризующее трудоемкость тестирования программы. Для вычисления цикломатического числа Маккейба Z(G) применяется формула Z(G) = l-v+2p, где l – число дуг ориентированного графа G; v – число вершин; p- число компонентов связности графа. Число компонентов связности графа можно рассматривать как количество дуг, которые необходимо добавить для преобразования графа сильносвязный. Сильносвязным называется граф, любые две вершины которого взаимно достижимы. Для графов корректных программ, т.е. графов, не имеющих недостижимых от точек входа участков и “висячих” входа и выхода, сильносвязный граф, как правило, получается путем замыкания одной вершины, обозначающей конец программы на вершину, обозначающую точку входа в эту программу. По сути Z(G) определяет число линейно независимых контуров в сильносвязном графе. Иначе говоря, цикломатическое число  Маккейба показывает требуемое число проходов для покрытия всех контуров сильносвязанного графа или количество тестовых прогонов программы, необходимых для исчерпывающего тестирования по критерию “работает каждая ветвь”.
* __метрики сложности потока данных программ__: то есть использования, конфигурации и размещения данных в программах. Пара “модуль – глобальная переменная” обозначается как (p,r), где p – модуль, имеющий доступ к глобальной переменной r. В зависимости от наличия в программе реального обращения к переменной r формируются два типа пар “модуль – глобальная переменная” : фактические и возможные. Возможное обращение к r с помощью p показывает, что область существования r включает в себя p.
  Характеристика Aup говорит о том, сколько раз модули Up действительно получили доступ к глобальным переменным, а число Pup – сколько раз они могли бы получить доступ.  Отношение числа фактических обращений к возможным определяется как __Rup=Aup/Pup__. Эта формула показывает приближенную вероятность ссылки произвольного модуля на произвольную глобальную переменную. Очевидно, чем выше эта вероятность, тем выше вероятность “несанкционированного” изменения какой-либо переменной, что может существенно осложнить работы, связанные с модификацией программы. 
   Еще одна метрика сложности потока данных – спен.
   Определение спена основывается на локализации обращения к данным внутри каждой программной секции.
   Спен – это число утверждений, содержащих данный идентификатор, между его первым и последним появлением в тексте программы. Идентификатор, появившийся n раз, имеет спен, равный n-1.
   Спен определяет количество контролирующих утверждений, вводимых в тело программы при построении трассы программы по этому идентификатору в процессе тестирования и отладки.
   Следующей метрикой сложности потока данных программ является **метрика Чепина**.  Существует несколько ее модификаций. Рассмотрим более простой, а с точки зрения практического использования – достаточно эффективный вариант этой метрики.
   Суть метода состоит в оценке информационной прочности отдельно взятого программного модуля с помощью анализа характера использования переменных из списка ввода-вывода.
   Все множество переменных, составляющих список ввода-вывода разбивается на четыре функциональные группы
	1.  Р – вводимые переменные для расчетов и для обеспечения вывода. Примером может служить используемая в программах лексического анализатора переменная, содержащая строку исходного текста программы, то есть сама переменная не модифицируется, а только содержит исходную информацию.
	2.  М – модифицируемые или создаваемые внутри программы переменные.
	3.  C – переменные, участвующие в управлении работой программного модуля (управляющие переменные).
	4.  Не используемые в программе (“паразитные”) переменные. Поскольку каждая переменная может выполнять одновременно несколько функций, необходимо учитывать ее в каждой соответствующей функциональной группе.
Далее вводится значение метрики Чепина:
   _Q = a1P + a2M + a3C + a4T_  ,где a1, a2, a3, a4 – весовые коэффициенты.
Весовые коэффициенты использованы для отражения различного влияния на сложность программы каждой функциональной группы. По мнению автора метрики, наибольший вес, равный трем, имеет функциональная группа С, так как  она влияет на поток управления программы. Весовые коэффициенты остальных групп распределяются следующим образом: a1=1; a2=2; a4=0.5. Весовой коэффициент группы T не равен нулю, поскольку “паразитные” переменные не увеличивают сложности потока данных программы, но иногда затрудняют ее понимание. С учетом весовых коэффициентов выражение примет вид: _Q = P + 2M + 3C + 0.5T_ .

---
<div class="page-break" style="page-break-before: always;"></div>

## __Понятийный аппарат метрической теории программ – принципы количественного анализа качества объектов с расплывчатыми свойствами.__

__Качество ПО__ — это совокупность свойств, определяющих полезность изделия (программы) для пользователей в соответствии с функциональным назначением и предъявленными требованиями.

__Характеристика качества программы__ - понятие, отражающее отдельные факторы, влияющие на качество программ и поддающиеся измерению.

__Критерий качества__ - численный показатель, характеризующий степень, в которой программе присуще оцениваемое свойство. Критерии качества включают следующие характеристики : экономичность, документированность, гибкость, модульность, надёжность, обоснованность, тестируемость, ясность, точность, модифицируемость, эффективность, легкость сопровождения и т.д.
Критерий должен:
* численно характеризовать основную целевую функцию программы;
* обеспечивать возможность определения затрат, необходимых для достижения требуемого уровня качества, а также степени влияния на показатель качества различных внешних факторов;
* быть по возможности простым, хорошо измеримым и иметь малую дисперсию.

Для измерения характеристик и критериев качества используют __метрики__. 
__Метрика качества программ__ - система измерений качества программ. Эти измерения могут проводиться на уровне критериев качества программ или на уровне отдельных характеристик качества. В первом случае система измерений позволяет непосредственно сравнивать программы по качеству. При этом сами измерения не могут быть проведены без субъективных оценок свойств программ. Во втором случае измерения характеристик можно выполнить объективно и достоверно, но оценка качества ПО в целом будет связана с субъективной интерпретацией получаемых оценок.

В исследовании метрик ПО различают два основных направления:
* поиск метрик, характеризующих наиболее специфические свойства программ, т.е. метрик оценки самого ПО;
* использование метрик для оценки технических характеристик и факторов разработки программ, т.е. метрик оценки условий разработки программ.

По виду информации, получаемой при оценке качества ПО метрики можно разбить на три группы:
* метрики, оценивающие отклонение от нормы характеристик исходных проектных материалов. Они устанавливают полноту заданных технических характеристик исходного кода.
* метрики, позволяющие прогнозировать качество разрабатываемого ПО. Они заданы на множестве возможных вариантов решений поставленной задачи и их реализации и определяют качество ПО, которое будет достигнуто в итоге.
* метрики, по которым принимается решение о соответствии конечного ПО заданным требованиям. Они позволяют оценить соответствие разработки заданным требованиям.

### ОСНОВНЫЕ НАПРАВЛЕНИЯ ПРИМЕНЕНИЯ МЕТРИК

В настоящее время в мировой практике используется несколько сотен метрик программ. Существующие качественные оценки программ можно сгруппировать по шести направлениям:

* оценки топологической и информационной сложности программ;
* оценки надежности программных систем, позволяющие прогнозировать отказовые ситуации;
* оценки производительности ПО и повышения его эффективности путем выявления ошибок проектирования;
* оценки уровня языковых средств и их применения;
* оценки трудности восприятия и понимания программных текстов, ориентированные на психологические факторы, существенные для сопровождения и модификации программ;
* оценки производительности труда программистов для прогнозирования сроков разработки программ и планирования работ по созданию программных комплексов.

### МЕТРИЧЕСКИЕ ШКАЛЫ

В зависимости от характеристик и особенностей применяемых метрик им ставятся в соответствие различные измерительные шкалы.

**Номинальной шкале** соответствуют метрики, классифицирующие программы на типы по признаку наличия или отсутствия некоторой характеристики без учета градаций.
**Порядковой шкале** соответствуют метрики, позволяющие ранжировать некоторое характеристики путем сравнения с опорными значениями, т.е. измерение по этой шкале фактически определяет взаимное положение конкретных программ.
**Интервальной шкале** соответствуют метрики, которые показывают не только относительное положение программ, но и то, как далеко они отстоят друг от друга.
**Относительной шкале** соответствуют метрики, позволяющие не только расположить программы определенным образом и оценить их положение относительно друг друга, но и определить, как далеко оценки отстоят от границы, начиная с которой характеристика может быть измерена.

### МЕТРИКИ СЛОЖНОСТИ ПРОГРАММ

При оценке сложности программ, как правило, выделяют три основные группы метрик:
* метрики размера программ
* метрики сложности потока управления программ
* метрики сложности потока данных программ

Для оценки качества ПО применяются методы для моделей с расплывчатыми характеристиками:

![[Pasted image 20250917143947.png]]

---
<div class="page-break" style="page-break-before: always;"></div>

## __Модель и метрики оценки сложности Боэма.__

Модель Б. Боэма — модель оценки качества ПО, которая позволяет более точно определять качество его основных характеристик, заданных набором показателей и метрик.  В её основе лежит оценка качества программного обеспечения на всех этапах его жизненного цикла. Эта модель относится к иерархическим моделям качества, в которых структурирование показателей осуществляется сначала на основе высокоуровневых, затем промежуточных и, наконец, индивидуальных характеристик:
$Е = 2,4 * K^{1,05}­$ и $T = 2,5 * E^{0,38}$ — к прикладному ПО
$Е = 3,6 * K^{1,2}$ и $T = 2,5 * E^{0,32}$ — к системному ПО
где:
	К – количество строк программного кода
	Е – трудоемкость (чел/мес)
	Т – продолжительность разработки (мес)

---
<div class="page-break" style="page-break-before: always;"></div>

## __Модель и метрики оценки сложности Холстэда.__

К группе оценок размера программ можно отнести также _метрику Холстеда_. За базу принят подсчет количества операторов и операндов используемых в программе, т.е. определение размера программы.
Основу метрики Холстеда составляют четыре измеряемые характеристики программы:
- $h_{1}$ — число уникальных операторов программы, включая символы-разделители, имена процедур и знаки операций (словарь операторов);
- $h_{2}$ – число уникальных операндов программы (словарь операндов);
- $N_{1}$ – общее число операторов в программе;
- $N_{2}$ – общее число операндов в программе.

Опираясь на эти характеристики, получаемые непосредственно при анализе исходных текстов программ, Холстед вводит следующие оценки:
- Словарь программы: $h=h_{1} + h_{2}$
- Длину программы: $N=N_{1}+N_{2}$
- Объем программы: $V=N*log_{2}{h}$

Смысл оценок h и N достаточно очевиден, поэтому подробно рассмотрим только характеристику V. Количество символов, используемых при реализации некоторого алгоритма, определяется в числе прочих параметров и словарей программы h, представляющим собой минимально необходимое число символов, обеспечивающих реализацию алгоритма.
Далее Холстед вводит h* — теоретический словарь программы, т.е. словарный запас, необходимый для написания программы с учетом того, что необходимая функция уже реализована в данном языке и, следовательно, программа сводится к вызову этой функции. Например, согласно Холстеду возможное осуществление процедуры выделения простого числа могло бы выглядеть так:
						`CALL SIMPLE (X, Y),
где Y- массив численных значений, содержащих искомое число X. Теоретический словарь в этом случае будет состоять из
						`n1*: {CALL, SIMPLE (...)} n1*=2;
						`n2*: {X,Y}, h2*=2;
а его длина, определяемая как $h^* = h_{1}^* + h_{2}^*$ будет равна 4.

Используя h*, Холстед вводит оценку V*: $V^* = h*log_{2}h$, с помощью которой описывается потенциальный объем программы, соответствующий максимально компактно реализующей данный алгоритм.

---
<div class="page-break" style="page-break-before: always;"></div>

## __Модель и метрики оценки сложности Мак-Кейба (основанные на потоковых графах).__

Как правило, с помощью метрик сложности потока управления программ оперируют либо плотностью управляющих переходов внутри программ, либо взаимосвязями этих переходов. И в том и в другом случае стало традиционным представление программ в виде управляющего ориентированного графа $G(V,E)$, где $V$ – вершины, соответствующие операторам, $E$ – дуги, соответствующие переходам.
В дуге $(U,V)$ – вершина $V$ является исходной, а $U$ – конечной. При этом $U$ непосредственно следует $V$, а $V$ непосредственно предшествует $U$. Если путь от $V$ до $U$ состоит более чем из одной дуги, тогда $U$ следует за $V$, а $V$ предшествует $U$.

Впервые графическое представление программ было предложено __Мак-Кейбом__. Основной метрикой сложности он предлагает считать _цикломатическую сложность графа программы_, или, как еще называют, цикломатическое число Маккейба, _характеризующее трудоемкость тестирования программы_. Для вычисления цикломатического числа Маккейба $Z(G)$ применяется формула
						$Z(G) = l-v+2p$, 
где $l$ — число дуг ориентированного графа $G$;
$v$ — число вершин (операторы);
$p$ — число компонентов связности графа, его можно рассматривать как количество дуг, которые необходимо добавить для преобразования графа в сильносвязный. 
_Сильносвязным_ называется граф, любые две вершины которого взаимно достижимы. Для графов корректных программ, т.е. графов, не имеющих недостижимых от точек входа участков и “висячих” входа и выхода, сильносвязный граф, как правило, получается путем замыкания одной вершины, обозначающей конец программы на вершину, обозначающую точку входа в эту программу.
По сути $Z(G)$ определяет число линейно независимых контуров в сильносвязном графе. Иначе говоря, цикломатическое число Маккейба показывает требуемое число проходов для покрытия всех контуров сильносвязанного графа или количество тестовых прогонов программы, необходимых для исчерпывающего тестирования по критерию “работает каждая ветвь”.
![[Pasted image 20250917150957.png]]
(Вершины графа – операторы, стрелка – переход от одного оператора к другому. Case считается как один оператор.)

---
<div class="page-break" style="page-break-before: always;"></div>

## __Модель и метрики, основанные на информационных потоках.__

Задолго до того, как программисты приступят к разработке программного обеспечения, облик будущего программного изделия должен быть определен в схематическом виде. Это представление должно отражать структуру АИС, порядок ее взаимодействия с внешней средой и быть однозначно понятным как разработчикам, так и будущим пользователям.

Такая формализованная модель оказывается чрезвычайно полезной на начальных стадиях создания АИС, когда разработчики должны четко уяснить сами и объяснить заказчику на понятном ему языке, что же будет представлять собой новая АИС как единая система.

Для решения указанной задачи предусматривается разработка модели информационных потоков (МИП), выполняемую параллельно с определением требований к будущей системе. МИП позволяет разработчикам:

- построить представление о том, как работает автоматизируемый объект;
- найти взаимопонимание с будущими пользователями;
- выявить требования к системе;
- в дальнейшем определить структуру системы.

Перечисленные требования отражают в комплекте проектных документов, получившем название «Модель информационных потоков» (МИП). Основу МИП составляют формализованные графические документы «Схемы информационных потоков» (СИП). Кроме того, в состав МИП входят текстовые и табличные документы, содержащие дополнительные сведения о внешних объектах, хранилищах данных, задачах и информационных потоках.

СИП и сопутствующая документация служат моделью потоков информации между системой и внешним миром, а также потоков внутри системы независимо от их временной структуры.

Основная цель моделирования информационных потоков состоит в том, чтобы получить достаточно наглядное средство взаимодействия между проектировщиком и заказчиком при определении требований к разрабатываемому ПИ и принятии общесистемных проектных решений.

На схеме информационных потоков отображают:
1) границы системы или рассматриваемой ее отдельной задачи;
2) внешние объекты (ВО), обменивающиеся данными с системой;
3) задачи, обрабатывающие информацию, порождающие потоки данных и обеспечивающие их поиск и хранение;
4) потоки входной и выходной информации, пересекающие границы системы (задачи);
5) потоки данных в пределах границ системы (задачи);
6) хранилища данных (ХД).

МИП составляется как для существующей системы, так и для разрабатываемого ПИ. При этом МИП будущего ПИ разрабатывают путём преобразования описания существующей системы (традиционной неавтоматизированной или применяемой автоматизированной). Это преобразование выполняют путем логического абстрагирования от деталей физической реализации, выражая при этом точку зрения пользователей.

Одной из целей составления МИП разрабатываемого ПИ является также облегчение выявления автоматизируемых функций и задач.



---
<div class="page-break" style="page-break-before: always;"></div>

## __Методы оценки качества программного обеспечения: анкетирование, рабочие списки, контрольные задачи, метрики. Государственные стандарты в области оценки качества программного обеспечения.__

По объему ПО делят:
1) ПО большого объема (более $10^5$ операторов: ОС, языки программирования и др. широко используемые программы)
2) ПО большого объема для узкой сферы применения (ПО для телефонной связи, …)
3) ПО среднего объема ($10^4$ – $10^5$ команд) или широкого или узкого применения
4) ПО небольшого объема и конкретного применения ($10^3­$ – $10^4$ команд)

Методы оценки:
1) Методы оценки с помощью метрик;
2) Методы анкетирования. В основе лежит применение специальных анкет из 100-200 вопросов. С помощью этих анкет создаются атласы ПО, которые используются для качественной и количественной оценки. Пользователи сравнивают разные ПО и заполняют анкеты. Данный метод следует применять для ПО большого объема и широкого применения.
3) Метод «рабочие списки» позволяет оценить характеристики ПО на следующих уровнях ЖЦ:
	- уровень анализа систем;
	- уровень проекта систем;
	- уровень проекта модуля;
	- уровень программы модуля;
4) Метод «контрольные задачи» (метод измерения качества по конечному результату) Оценивается не алгоритм, а метод его реализации. Используется для ПО малого и среднего объема.

_(Рабочие списки – анкеты для специалистов, 200-300 вопросов, применяются интервальные шкалы. В отличии от метода анкетирования, уменьшается фактор субъективизма. Этот метод с большими трудозатратами и используется для ПО большого и среднего объема.)_

### __Гос. стандарты__

- __ГОСТ Р ИСО/МЭК 9126-93 «Информационная технология. Оценка программной продукции. Характеристики качества и руководства по их применению»__: стандарт определяет 6 характеристик качества программного обеспечения, служащих основой для их оценки и описания (функциональность, надежность, удобство использования, эффективность, сопровождаемость, переносимость), описывает данные характеристики как основу для оценки качества ПО без указания конкретных метрик, оставляя методики измерения на усмотрение пользователей стандарта. Этот подход позволяет унифицировать оценку и повысить объективность анализа качества ПО, учитывать как технические, так и эксплуатационные аспекты. Стандарт широко применяется для формирования требований, тестирования и сравнения программных продуктов.
- __ГОСТ 28195-89 «Оценка программных средств. Общее положение»__: регламентирует общие положения оценки качества программных средств на протяжении всего жизненного цикла разработки и эксплуатации. В нем определены показатели и методы оценки, применяемые для измерения различных аспектов качества ПО, включая:
	- Спецификацию требований к программному средству.
    - Функциональные и нефункциональные характеристики.
    - Методы тестирования и контроля качества.
- __ГОСТ Р ИСО/МЭК 25000 (SQuaRE)__: представляет собой развитие и расширение ISO/IEC 9126, включая более современные и детализированные требования к качеству программного обеспечения и систем. Комплекс включает части, посвященные:
	- Основным понятиям и моделям качества.
    - Требованиям к программному обеспечению.
    - Метрикам и методикам оценки качества.
    - Качеству использования (quality in use).
- __ГОСТ Р ИСО/МЭК 25066-2019__: этот стандарт сфокусирован на системной и программной инженерии, устанавливает требования и методы оценки качества программного обеспечения с учетом современных технологических тенденций и процессов жизненного цикла. Он помогает формализовать подход к обеспечению качества в рамках разработки, сопровождения и эксплуатации ПО.
- __ГОСТ Р 56939-2024__: устанавливает требования к процессам разработки и оценке соответствия программных продуктов. Он направлен на производителей и заказчиков ПО и учитывает современные методы и практики обеспечения качества.

---
<div class="page-break" style="page-break-before: always;"></div>

## __Модули, сцепление и связность — критерии независимости модулей, библиотеки ресурсов.__

При проектировании достаточно сложного программного обеспечения после определения его общей структуры выполняют декомпозицию компонентов в соответствии с выбранным подходом до получения элементов, которые, по мнению проектировщика, в дальнейшей декомпозиции не нуждаются.

В настоящее время используют два способа декомпозиции разрабатываемого программного обеспечения, связанные с соответствующим подходом:
- процедурный (или структурный - по названию подхода);
- объектный.

Результатом процедурной декомпозиции является _иерархия подпрограмм_ (процедур), в которой функции, связанные с принятием решения, реализуются подпрограммами верхних уровней, а непосредственно обработка - подпрограммами нижних уровней. Это согласуется с _принципом вертикального управления_, который был сформулирован вместе с другими рекомендациями структурного подхода к программированию. Он также ограничивает возможные варианты передачи управления, требуя, чтобы любая подпрограмма возвращала управление той подпрограмме, которая ее вызвала.

Результатом объектной декомпозиции является совокупность объектов, которые затем реализуют как переменные некоторых специально разрабатываемых типов (классов), представляющих собой совокупность полей данных и методов, работающих с этими полями.

Таким образом, при любом способе декомпозиции получают набор связанных с соответствующими данными подпрограмм, которые в процессе реализации организуют в модули.

### **Модули.**
_Модулем_ называют _автономно компилируемую_ программную единицу. Термин «модуль» традиционно используется в двух смыслах. Первоначально, когда размер программ был сравнительно невелик, и все подпрограммы компилировались отдельно, под модулем понималась подпрограмма, т. е. _последовательность связанных фрагментов программы, обращение к которой выполняется по имени._ Со временем, когда размер программ значительно вырос, и появилась возможность создавать библиотеки ресурсов: констант, переменных, описаний типов, классов и подпрограмм, термин «модуль» стал использоваться и в смысле _автономно компилируемый набор программных ресурсов._

Данные модуль может получать и/или возвращать через общие области памяти или параметры. Первоначально к модулям (еще понимаемым как подпрограммы) предъявлялись следующие требования:

- отдельная компиляция;
- одна точка входа;
- одна точка выхода;
- соответствие принципу вертикального управления;
- возможность вызова других модулей;
- небольшой размер (до 50-60 операторов языка);
- независимость от истории вызовов;
- выполнение одной функции.

Требования одной точки входа, одной точки выхода, независимости от истории вызовов и соответствия принципу вертикального управления были вызваны тем, что в то время из-за
серьезных ограничений на объем оперативной памяти программисты были вынуждены
разрабатывать программы с максимально возможной повторяемостью кодов. В результате подпрограммы, имеющие несколько точек входа и выхода, были не только обычным явлением, но и считались высоким классом программирования. Следствием же было то, что программы было очень сложно не только модифицировать, но и понять, а иногда и просто полностью отладить.

Со временем, когда основные требования структурного подхода стали поддерживаться
языками программирования, и под модулем стали понимать отдельно компилируемую библиотеку ресурсов, требование независимости модулей стало основным.

Практика показала, что чем выше степень независимости модулей, тем:
- легче разобраться в отдельном модуле и всей программе и, соответственно, тестировать, отлаживать и модифицировать ее;
- меньше вероятность появления новых ошибок при исправлении старых или внесении изменений в программу, т. е. вероятность появления «волнового» эффекта;
- проще организовать разработку программного обеспечения группой программистов и легче его сопровождать.

Таким образом, уменьшение зависимости модулей улучшает технологичность проекта.
Степень независимости модулей (как подпрограмм, так и библиотек) оценивают двумя критериями: сцеплением и связностью.

### **Сцепление модулей.** 
_Сцепление_ является мерой взаимозависимости модулей, которая определяет, насколько хорошо модули отделены друг от друга. Модули независимы, если каждый из них не содержит о другом никакой информации. Чем больше информации о других модулях хранит модуль, тем больше он с ними сцеплен.

Различают пять типов сцепления модулей:
- по данным;
- по образцу;
- по управлению;
- по общей области данных;
- по содержимому.

_Сцепление по данным_ предполагает, что модули обмениваются данными, представленными скалярными значениями. При небольшом количестве передаваемых параметров этот тип обеспечивает наилучшие технологические характеристики программного обеспечения. Например, функция Мах предполагает сцепление по данным через параметры скалярного типа:
```pascal
Function Max(a, b: integer): integer;
begin
	if a>b then Max:=a
	else Max: =b;
end;
```

_Сцепление по образцу_ предполагает, что модули обмениваются данными, объединенными в структуры. Этот тип также обеспечивает неплохие характеристики, но они хуже, чем у 
предыдущего типа, так как конкретные передаваемые данные «спрятаны» в структуры, и потому уменьшается «прозрачность» связи между модулями. Кроме того, при изменении структуры передаваемых данных необходимо модифицировать все использующие ее модули.
Так, функция MaxEl, описанная ниже, предполагает сцепление по образцу (параметр а —
открытый массив).
```pascal
Function MaxEl(a:array of integer): integer;
Var i:word;
begin
	MaxEl: =a [O];
	for i: =l to High (a) do
	if a [i]>MaxEl then MaxEl: =a [i];
end;
```

При _сцеплении по управлению_ один модуль посылает другому некоторый информационный объект (флаг), предназначенный для управления внутренней логикой модуля. Таким способом часто выполняют настройку режимов работы программного обеспечения. Подобные настройки также снижают наглядность взаимодействия модулей и потому обеспечивают еще худшие характеристики технологичности разрабатываемого программного обеспечения по сравнению с предыдущими типами связей.

Например, функция MinMax предполагает сцепление по управлению, так как значение параметра flag влияет на логику программы: если функция MinMax получает значение параметра flag, равное true, то возвращает максимальное значение из двух, а если false, то минимальное:
```pascal
Function MinMax (a, b: integer; flag:boolean): integer;
begin
	if(a>b) and (flag) then MinMax: =a
	else MinMax: =b;
end;
```

_Сцепление по общей области данных_ предполагает, что модули работают с общей областью данных. Этот тип сцепления считается недопустимым, поскольку:
- программы, использующие данный тип сцепления, очень сложны для понимания при сопровождении программного обеспечения;
- ошибка одного модуля, приводящая к изменению общих данных, может проявиться при выполнении другого модуля, что существенно усложняет локализацию ошибок;
- при ссылке к данным в общей области модули используют конкретные имена, что уменьшает гибкость разрабатываемого программного обеспечения.

Например, функция МахА, использующая глобальный массив А, сцеплена с основной программой по общей области:
```pascal
Function MaxA: integer;
Var i:word;
begin
	МахА: =a[Low(a)];
	for i: = Low (a) + l to High(a) do
	if a [i]>MaxA then MaxA: = a [i];
end;
```

Следует иметь в виду, что «подпрограммы с памятью», действия которых зависят от истории
вызовов, используют сцепление по общей области, что делает их работу в общем случае
непредсказуемой. Именно этот вариант используют статические переменные С и C++.

В случае _сцепления по содержимому_ один модуль содержит обращения к внутренним
компонентам другого (передает управление внутрь, читает и/или изменяет внутренние данные или сами коды), что полностью противоречит блочно-иерархическому подходу.

Допустимыми считают первые три типа сцепления, так как использование остальных приводит к резкому ухудшению технологичности программ.

В некоторых случаях сцепление модулей можно уменьшить, удалив необязательные связи и структурировав необходимые связи. Примером может служить объектно-ориентированное программирование, в котором вместо большого количества параметров метод неявно получает адрес области (структуры), в которой расположены поля объекта, и явно-дополнительные параметры. В результате модули оказываются сцепленными по образцу.

### **Связность модулей.**
_Связность_ - мера прочности соединения функциональных и информационных объектов внутри одного модуля. Если сцепление характеризует качество отделения модулей, то связность характеризует степень взаимосвязи элементов, реализуемых одним модулем. Размещение сильно связанных элементов в одном модуле уменьшает межмодульные связи и, соответственно, взаимовлияние модулей. В то же время помещение сильно связанных элементов в разные модули не только усиливает межмодульные связи, но и усложняет понимание их взаимодействия. Объединение слабо связанных элементов также уменьшает технологичность модулей, так как такими элементами сложнее мысленно манипулировать.


![[Pasted image 20250918143345.png | 350]]
Различают следующие виды связности (в порядке убывания уровня):
- функциональную;
- последовательную;
- информационную (коммуникативную);
- процедурную;
- временную;
- логическую;
- случайную.

При __функциональной связности__ все объекты модуля предназначены для выполнения одной функции: операции, объединяемые для выполнения одной функции, или данные, связанные с одной функцией. Модуль, элементы которого связаны функционально, имеет четко определенную цель, при его вызове выполняется одна задача, например, подпрограмма поиска минимального элемента массива. Такой модуль имеет максимальную связность, следствием которой являются его хорошие технологические качества: простота тестирования, модификации и сопровождения.

При __последовательной связности__ выход одной функции служит исходными данными для другой функции. Как правило, такой модуль имеет одну точку входа, т.е. реализует одну подпрограмму, выполняющую две функции. Считают, что данные, используемые последовательными функциями, также связаны последовательно. Модуль с последовательной связностью функций можно разбить на два или более модулей, как с последовательной, так и с функциональной связностью. Такой модуль выполняет несколько функций, и, следовательно, его технологичность хуже: сложнее организовать тестирование, а при выполнении модификации мысленно приходится разделять функции модуля.

__Информационно связанными__ считают функции, обрабатывающие одни и те же данные. Несмотря на объединение нескольких функций, информационно связанный модуль имеет неплохие показатели технологичности. Это объясняется тем, что все функции, работающие с некоторыми данными, собраны в одно место, что позволяет при изменении формата данных корректировать только один модуль. Информационно связанными также считают данные, которые обрабатываются одной функцией.

__Процедурно связаны__ функции или данные, которые являются частями одного процесса (рис. 2.1, г). Обычно модули с процедурной связностью функций получают, если в модуле объединены функции альтернативных частей программы. При процедурной связности отдельные элементы модуля связаны крайне слабо, так как реализуемые ими действия связаны лишь общим процессом, следовательно, технологичность данного вида связи ниже, чем предыдущего.

__Временная связность__ функций подразумевает, что эти функции выполняются параллельно или в течение некоторого периода времени (рис. 2.1, д). Временная связность данных означает, что они используются в некотором временном интервале. Например, временную связность имеют функции, выполняемые при инициализации некоторого процесса. Отличительной особенностью временной связности является то, что действия, реализуемые такими функциями, обычно могут выполняться в любом порядке. Содержание модуля с временной связностью функций имеет тенденцию меняться: в него могут включаться новые действия и/или исключаться старые. Большая вероятность модификации функции еще больше уменьшает показатели технологичности модулей данного вида по сравнению с предыдущим.

__Логическая связь__ базируется на объединении данных или функций в одну логическую группу (рис. 2.1, е). В качестве примера можно привести функции обработки текстовой информации или данные одного и того же типа. Модуль с логической связностыо функций часто реализует альтернативные варианты одной операции, например, сложение целых чисел и сложение вещественных чисел. Из такого модуля всегда будет вызываться одна какая-либо его часть, при этом вызывающий и вызываемый модули будут связаны по управлению. Понять логику работы модулей, содержащих логически связанные компоненты, как правило, сложнее, чем модулей, использующих временную связность, следовательно, их показатели технологичности еще ниже.

В том случае, если связь между элементами мала или отсутствует, считают, что они имеют
__случайную связность__. Модуль, элементы которого связаны случайно, имеет самые низкие
показатели технологичности, так как элементы, объединенные в нем, вообще не связаны.

На практике целесообразно использовать функциональную, последовательную и информационную связности.

### **Библиотеки ресурсов.**
Различают библиотеки ресурсов двух типов: _библиотеки подпрограмм_ и _библиотеки классов_.

__Библиотеки подпрограмм__ реализуют функции, близкие по назначению, например, библиотека графического вывода информации. Связность подпрограмм между собой в такой библиотеке - логическая, а связность самих подпрограмм - функциональная, так как каждая из них обычно реализует одну функцию.

__Библиотеки классов__ реализуют близкие по назначению классы. Связность элементов класса - информационная, связность классов между собой может быть функциональной - для родственных или ассоциированных классов и логической - для остальных.

В качестве средства улучшения технологических характеристик библиотек ресурсов в настоящее время широко используют разделение тела модуля на интерфейсную часть и область реализации. _Интерфейсная часть_ в данном случае содержит совокупность объявлений ресурсов (заголовков подпрограмм, имен переменных, типов, классов и т. п.), которые данная библиотека предоставляет другим модулям. Ресурсы, объявление которых в интерфейсной части отсутствует, извне не доступны. Область _реализации_ содержит тела подпрограмм и, возможно, внутренние ресурсы (подпрограммы, переменные, типы), используемые этими подпрограммами.

---
<div class="page-break" style="page-break-before: always;"></div>

## __Нисходящий и восходящий подход к разработке программного обеспечения, средства описания структурных алгоритмов: базовые и дополнительные алгоритмические структуры, псевдокоды, Flow-формы, диаграммы Насси-Шнейдермана.__

При проектировании, реализации и тестировании компонентов структурной иерархии, полученной при декомпозиции, применяют два подхода:
- восходящий;
- нисходящий.

###  **Восходящий подход.**
При использовании восходящего подхода сначала проектируют и реализуют компоненты нижнего уровня, затем предыдущего и т. д. По мере завершения тестирования и отладки компонентов осуществляют их сборку, причем компоненты нижнего уровня при таком подходе часто помещают в библиотеки компонентов. Для тестирования и отладки компонентов проектируют и реализуют специальные тестирующие программы.

Недостатки:
- увеличение вероятности несогласованности компонентов вследствие неполноты спецификаций;
- наличие издержек на проектирование и реализацию тестирующих программ, которые нельзя преобразовать в компоненты;
- позднее проектирование интерфейса, а соответственно невозможность продемонстрировать его заказчику для уточнения спецификаций и т. д.

Исторически восходящий подход появился раньше, что связано с особенностью мышления программистов, которые в процессе обучения привыкают при написании небольших  программ сначала детализировать компоненты нижних уровней (подпрограммы, классы). Это позволяет им лучше осознавать процессы верхних уровней. ___При промышленном изготовлении ПО данный подход не используют.___

### **Нисходящий подход.**
Вначале проектируют модули верхних уровней, затем следующих и так далее до самых нижних уровней. При этом в процессе программирования компоненты нижних, еще не реализованных уровней заменяют специально разработанными «заглушками» - программы ни чего не выполняющие, что позволяет тестировать и отлаживать уже реализованную часть.

Нисходящий подход может быть реализован 3 способами:
1. **Иерархический метод** предполагает выполнение разработки строго по уровням. Основной проблемой данного метода является большое количество достаточно сложных заглушек. Кроме того, при использовании данного метода основная масса модулей разрабатывается и реализуется в конце работы над проектом, что затрудняет распределение человеческих ресурсов.

2. **_Операционный метод_** связывает последовательность выполнения при запуске программы. Применение метода усложняется тем, что порядок выполнения модулей может зависеть от данных. Кроме того, модули вывода результатов, несмотря на то, что они вызываются последними, должны разрабатываться одними из первых, чтобы не проектировать сложную заглушку, обеспечивающую вывод результатов при тестировании.

3. **_Комбинированный метод_** учитывает следующие факторы, влияющие на последовательность разработки:
- достижимость модуля - наличие всех модулей в цепочке вызова данного модуля;
- зависимость по данным - модули, формирующие некоторые данные, должны создаваться раньше обрабатывающих;
- обеспечение возможности выдачи результатов - модули вывода результатов должны создаваться раньше обрабатывающих;
- готовность вспомогательных модулей - вспомогательные модули, например, модули закрытия файлов, завершения программы, должны создаваться раньше обрабатывающих;
- наличие необходимых ресурсов.

Кроме того, при прочих равных условиях сложные модули должны разрабатываться прежде простых, так как при их проектировании могут выявиться неточности в спецификациях, а чем раньше это произойдет, тем лучше.

Нисходящий подход обеспечивает:
- максимально полное определение спецификаций проектируемого компонента и согласованность компонентов между собой;
- раннее определение интерфейса пользователя, демонстрация которого заказчику позволяет уточнить требования к создаваемому программному обеспечению:
- возможность нисходящего тестирования и комплексной отладки

Базовые алгоритмические структуры:
- _следование_ - обозначает последовательное выполнение действий;
- _ветвление_ - соответствует выбору одного из двух вариантов действий;
- _цикл-пока_ - определяет повторение действий, пока не будет нарушено некоторое условие, выполнение которого проверяется в начале цикла.

Дополнительные алгоритмические структуры (можно составить из базовых):
- _выбор_ - обозначает выбор одного варианта из нескольких в зависимости от значения некоторой величины;
- _цикл-do_ - обозначает повторение некоторых действий до выполнения заданного условия, проверка которого осуществляется после выполнения действий в цикле;
- _цикл с заданным числом повторений_ (счетный цикл) - обозначает повторение некоторых действий указанное количество раз.

**Псевдокоды** - формализованное текстовое описание алгоритма (текстовая нотация).

**Flow-формы** представляют собой графическую нотацию описания структурных алгоритмов, которая иллюстрирует вложенность структур. Каждый символ Flow-формы соответствует управляющей структуре и изображается в виде прямоугольника. Для демонстрации вложенности структур символ Flow-формы может быть вписан в соответствующую область прямоугольника любого другого символа. В прямоугольниках символов содержится текст на естественном языке или в математической нотации. Размер прямоугольника определяется длиной вписанного в него текста и размерами вложенных прямоугольников.

![](file:///C:/Users/843E~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif)


### **Диаграммы Насси-Шнейдермана.**
_Диаграммы Насси-Шнейдермана_ являются развитием Flow-форм. Основное их отличие от Flow-форм заключается в том, что область обозначения условий и вариантов ветвления изображают в виде треугольников. Такое обозначение обеспечивает большую наглядность представления алгоритма.

![](file:///C:/Users/843E~1/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif)

Также, как при использовании псевдокодов, описать неструктурный алгоритм, применяя Flow- формы или диаграммы Насси-Шнейдермана, невозможно (для неструктурных передач управления в этих нотациях просто отсутствуют условные обозначения). В то же время, являясь графическими, эти нотации лучше отображают вложенность конструкций, чем псевдокоды.

Общим недостатком Flow-форм и диаграмм Насси-Шнейдермана является сложность построения изображений символов, что усложняет практическое применение этих нотаций для описания больших алгоритмов.

---
<div class="page-break" style="page-break-before: always;"></div>

## Программирование с защитой от ошибок: проверка выполнения операций, контроль промежуточных результатов, снижение погрешностей результатов, обработка исключений; сквозной структурный контроль.

Любая из ошибок программирования, которая не обнаруживается на этапах компиляции и компоновки программы, в конечном счете может проявиться тремя способами: привести к выдаче системного сообщения об ошибке, «зависанию» компьютера и получению неверных результатов.
![[Pasted image 20250918172245.png | 400]]

Однако до того, как результат работы программы становится фатальным, ошибки обычно много раз проявляются в виде неверных промежуточных результатов, неверных управляющих переменных, неверных типах данных, индексах структур данных и т. п. (рис. 2.10). А это значит, что часть ошибок можно попытаться обнаружить и нейтрализовать, пока они еще не привели к тяжелым последствиям.
Программирование, при котором применяют специальные приемы раннего обнаружения и нейтрализации ошибок, было названо _защитным или программированием с защитой от ошибок._ При его использовании существенно уменьшается вероятность получения неверных результатов.
Детальный анализ ошибок и их возможных ранних проявлений показывает, что целесообразно проверять:
- правильность выполнения операций ввода-вывода;
- допустимость промежуточных результатов (значений управляющих переменных, значений индексов, типов данных, значений числовых аргументов и т. д.).

### __Проверки правильности выполнения операций ввода-вывода__
Причинами неверного определения исходных данных могут являться, как внутренние  ошибки-ошибки устройств ввода-вывода или программного обеспечения, так и внешние ошибки - ошибки пользователя. При этом принято различать:
- ошибки передачи - аппаратные средства, например, вследствие неисправности, искажают данные;
- ошибки преобразования - программа неверно преобразует исходные данные из входного формата во внутренний;
- ошибки перезаписи - пользователь ошибается при вводе данных, например, вводит лишний или другой символ;
- ошибки данных - пользователь вводит неверные данные. Ошибки передачи обычно контролируются аппаратно.
Для защиты от ошибок преобразования данные после ввода обычно сразу демонстрируют
пользователю («эхо»). При этом выполняют сначала преобразование во внутренний формат, а затем обратно. Однако предотвратить все ошибки преобразования на данном этапе обычно крайне сложно, поэтому соответствующие фрагменты программы тщательно тестируют, используя методы эквивалентного разбиения и граничных значений (см. S 9.4). Обнаружить и устранить ошибки перезаписи можно только, если пользователь вводит избыточные данные, например контрольные суммы. Если ввод избыточных данных по каким-либо причинам нежелателен, то следует по возможности проверять вводимые данные, хотя бы контролировать интервалы возможных значений, которые обычно определены в техническом задании, и выводить введенные данные для проверки пользователю. Неверные данные обычно может обнаружить только пользователь.

### __Проверка допустимости промежуточных результатов__
Проверки промежуточных результатов позволяют снизить вероятность позднего проявления не только оппок неверного определения данных, но и некоторых ошибок кодирования и проектирования. Для того чтобы такая проверка была возможной, необходимо, чтобы в программе использовались переменные, для которых существуют ограничения любого происхождения, например, связанные с сущностью моделируемых процессов. Однако следует также иметь в виду, что любые дополнительные операции в программе требуют использования дополнительных ресурсов (времени, памяти и т. п.) и могут также содержать ошибки. Поэтому имеет смысл проверять не все промежуточные результаты, а только те, проверка которых целесообразна, т. е. возможно позволит обнаружить ошибку, и не сложна. Например:
- если каким-либо образом вычисляется индекс элемента массива, то следует проверить, что этот индекс является допустимым;
- если строится цикл, количество повторений которого определяется значением переменной, то целесообразно убедиться, что значение этой переменной не отрицательно;
- если определяется вероятность какого-либо события, то целесообразно проверить, что полученное значение не более 1, а сумма вероятностей всех возможных независимых событий равна 1 и т. д.
Предотвращение накопления погрешностей. Чтобы снизить погрешности результатов
вычислений, необходимо соблюдать следующие рекомендации:
- избегать вычитания близких чисел (машинный ноль);
- избегать деления больших чисел на малые;
- сложение длинной последовательности чисел начинать с меньших по абсолютной величине;
- стремиться по возможности уменьшать количество операций;
- использовать методы с известными оценками погрешностей;
- не использовать условие равенства вещественных чисел;
- вычисления производить с двойной точностью, а результат выдавать с одинарной.
### __Обработка исключений__
Поскольку полный контроль данных на входе и в процессе вычислений, как правило, невозможен, следует предусматривать перехват обработки аварийных Для перехвата и обработки аппаратно и программно фиксируемых ошибок в некоторых языках программирования, например, Delphi Pascal, C+F Java, предусмотрены средства обработки исключений. Использование эти средств позволяет не допустить выдачи пользователю сообщения об аварийном завершении программы, ничего ему не говорящего. Вместо этого программист получает возможность предусмотреть действия, которые позволяют исправить эту ошибку или, если это невозможно, выдать пользователю сообщение с точным описанием ситуации и продолжить работу.

---
<div class="page-break" style="page-break-before: always;"></div>

## Разработка и анализ требований к программному обеспечению: определение целей проектируемого программного обеспечения, определение целей управления проектом; техническое задание и спецификации программного обеспечения; функциональные и нефункциональные требования.

Постановка задачи — это процесс формулировки назначения программного обеспечения и основных требований к нему.  В процессе _постановки задачи_ четко формулируют назначение программного обеспечения и определяют основные требования к нему,  описываются функциональные и эксплуатационные требования. Каждое требование представляет собой описание необходимого или желаемого свойства программного обеспечения.
Различают _функциональные требования_, определяющие функции, которые должно выполнять разрабатываемое программное обеспечение, и _эксплуатационные требования_, определяющие особенности его функционирования.
Требования к программному обеспечению, имеющему _прототипы_, обычно определяют по
аналогии, учитывая структуру и характеристики уже существующего программного обеспечения.

Для формулирования требований к программному обеспечению, не имеющему аналогов, иногда необходимо провести специальные исследования, называемые предпроектными. В процессе таких исследований определяют разрешимость задачи, возможно, разрабатывают методы ее решения (если они новые) и устанавливают наиболее существенные характеристики разрабатываемого программного обеспечения. Для выполнения предпроектных исследований, как правило, заключают договор на выполнение научно-исследовательских работ. В любом случае этап постановки задачи заканчивается разработкой _технического задания_, фиксирующего принципиальные требования, и принятием основных проектных решений.

### Техническое задание и спецификации программного обеспечения

Техническое задание в соответствии со стандартом ГОСТ 19.201—78 «Техническое задание. Требования к содержанию и оформлению» имеет следующие основные разделы:
- введение: наименование и краткая характеристика программного обеспечения;
- основание для разработки;
- назначение разработки: описание функционального и эксплуатационного назначения, спецификации функций;
- требования к программному изделию: к функциональным характеристикам, к надежности, к техническим средствам;
- требования к программной документации;
- технологические требования.

Технологические требования определяют выбор следующих принципиальных решений, влияющих на процесс проектирования программного обеспечения: 
- архитектура программного обеспечения;
- пользовательский интерфейс; 
- метод программирования; 
- язык программирования; 
- среда программирования.
__Архитектурой программного обеспечения__ называют описание создаваемого программного обеспечения на уровне его компонентов и связей между ними. Архитектура программной системы во многом зависит от предметной области, для которой разрабатывается система. Поэтому часто архитектуры систем, разрабатываемых для одной и той же предметной области, имеют много общего. Следовательно, при проектировании архитектуры новой системы можно воспользоваться решениями, удачно примененными в ранее разработанных системах.

__Спецификациями__ называют полное и точное описание функций и ограничений разрабатываемого программного обеспечения. Существуют функциональные спецификации, описывающие функции разрабатываемого программного обеспечения, и эксплуатационные спецификации, описывающие требования к техническим средствам. Требование полноты означает строгое соответствие техническому заданию, а требование точности — однозначное толкование спецификаций разработчиком и заказчиком.
Спецификации содержат:
- декомпозицию и содержательную постановку задач;
- эксплуатационные ограничения;
- математические методы решения;
- модели программного обеспечения.

### Функциональные и нефункциональные требования

---
<div class="page-break" style="page-break-before: always;"></div>

## Технологические требования: выбор архитектуры ПО, выбор типа пользовательского интерфейса, выбор подхода к разработке, выбор языка и среды программирования.

На начальных этапах процесса проектирования должны быть приняты принципиальные решения, во многом определяющие этот процесс, а также качество и трудоемкость разработки. К таким решениям относят:

- выбор архитектуры программного обеспечения;
- выбор типа пользовательского интерфейса и технологии работы с документами;
- выбор подхода к разработке (структурного или объектного);
- выбор языка и среды программирования.

**Выбор архитектуры программного обеспечения.** _Архитектурой программного обеспечения_
называют совокупность базовых концепций (принципов) его построения. Архитектура ПО определяется сложностью решаемых задач, степенью универсальности разрабатываемого ПО и числом пользователей, одновременно работающих с одной его копией. Различают:

- однопользовательскую архитектуру, при которой программное обеспечение рассчитано на одного пользователя, работающего за персональным компьютером;
- многопользовательскую архитектуру, которая рассчитана на работу в локальной или глобальной сети.

Кроме того, в рамках однопользовательской архитектуры различают:
- программы;
- пакеты программ;
- программные комплексы;
- программные системы.

_Программой_ называют адресованный компьютеру набор инструкций, точно описывающий
последовательность действий, которые необходимо выполнить _для решения конкретной задачи._

При структурном подходе программы представляют собой иерархию подпрограмм, вызывающих друг друга в процессе решения поставленной задачи, при объектном подходе - совокупность обменивающихся сообщениями объектов, для реализации которых разработаны специальные классы. Программа в этом случае представляет собой отдельно компилируемую программную единицу, которая может использовать стандартные библиотеки подпрограмм, но, как правило, не организует свои. Это самый простой вид архитектуры, который обычно используется при решении небольших задач.

_Пакеты программ_ представляют собой _совокупность_ программ, решающих _задачи некоторой прикладной области_. Например, пакет графических программ, пакет математических программ. Программы такого пакета связаны между собой только принадлежностью к определенной прикладной области. Пакет программ реализуют как набор отдельных программ, каждая из которых сама вводит необходимые данные и выводит результаты.

_Программные комплексы_ представляют собой совокупность программ, _совместно_ обеспечивающих решение _небольшого класса сложных задач одной прикладной области._ Для решения такой задачи может потребоваться решить несколько подзадач, последовательно вызывая программы комплекса. Вызов программ в программном комплексе осуществляется специальной программой - _диспетчером,_ который обеспечивает несложный интерфейс с пользователем и, возможно, выдачу некоторой справочной информации. От пакета программ программный комплекс отличается еще и тем, что несколько программ могут последовательно или циклически вызываться для решения одной задачи, и, следовательно, желательно хранить исходные данные и результаты вызовов в пределах одного пользовательского проекта. Программы в этом случае могут реализовываться как отдельно, так и как совместно компилируемые программные единицы, а исходные данные храниться в оперативной памяти или в файлах.

_Программные системы_ представляют собой _организованную совокупность программ (подсистем)_, позволяющую решать _широкий класс задач из некоторой прикладной области_.

**Выбор типа пользовательского интерфейса.** Различают четыре типа пользовательских
интерфейсов:
- _примитивные_ - реализуют единственный сценарий работы, например, ввод данных - обработка - вывод результатов;
- _меню_ - реализуют множество сценариев работы, операции которых организованы в иерархические структуры, например, «вставка»: «вставка файла», «вставка символа» и т. д.;
- _со свободной навигацией_ - реализуют множество сценариев, операции которых не привязаны к уровням иерархии, и предполагают определение множества возможных операций на конкретном шаге работы; интерфейсы данной формы в основном используют Windows-приложения;
- _прямого манипулирования_ - реализуют множество сценариев, представленных в операциях над объектами, основные операции инициируются перемещением пиктограмм объектов мышью, данная форма реализована в интерфейсе самой операционной системы Windows альтернативно интерфейсу со свободной навигацией.

Тип пользовательского интерфейса во многом определяет сложность и трудоемкость разработки, которые существенно возрастают в порядке перечисления типов.

**Выбор подхода к разработке.** Если выбран интерфейс со свободной навигацией или прямого манипулирования, то, как указывалось выше, это практически однозначно предполагает использование событийного программирования и объектного подхода, так как современные среды визуального программирования, такие как Visual C++, Delphi, Builder C++ и им подобные, предоставляют интерфейсные компоненты именно в виде объектов библиотечных классов. При этом в зависимости от сложности предметной области программное обеспечение может реализовываться как с использованием объектов и, соответственно, классов, так и чисто процедурно. Исключение составляют случаи использования специализированных языков разработки Интернет-приложений, таких как Perl, построенных по совершенно другому принципу.

Примитивный интерфейс и интерфейс типа меню совместимы как со структурным, так и с
объектным подходами к разработке. Поэтому выбор подхода осуществляют с использованием дополнительной информации.

Практика показывает, что объектный подход эффективен для разработки очень больших
программных систем (более 100000 операторов универсального языка программирования) и в тех случаях, когда объектная структура предметной области ярко выражена.

Следует также учитывать, что необходимо осторожно использовать объектный подход при
жестких ограничениях на эффективность разрабатываемого программного обеспечения, например, при разработке систем резального времени.
Во всех прочих случаях выбор подхода остается за разработчиком.


**Выбор языка программирования.**

Язык может быть определен:
- организацией, ведущей разработку;
- программистом, который по возможности всегда будет использовать хорошо знакомый язык;
- устоявшимся мнением: если же все-таки выбор языка реально возможен, то нужно иметь в виду, что все существующие языки программирования можно разделить на следующие группы:
	- универсальные языки высокого уровня;
	- специализированные языки разработчика программного обеспечения(языки баз данных; языки создания сетевых приложений; языки создания систем искусственного интеллекта и т. д.)
	- специализированные языки пользователя (обычно являются частью профессиональных сред пользователя, характеризуются узкой направленностью и разработчиками ПО не используются.)
	- языки низкого уровня. (позволяют осуществлять программирование практически на уровне машинных команд)

**Выбор среды программирования.** _Средой программирования_ называют программный комплекс, который включает специализированный текстовый редактор, встроенные компилятор, компоновщик, отладчик, справочную систему и другие программы, использование которых упрощает процесс написания и отладки программ. (Delphi, C++ Builder и Visual C).

**Выбор или формирование стандартов разработки.** Реальное применение любой технологии проектирования требует формирования или выбора ряда стандартов, которые должны соблюдаться всеми участниками проекта:
- стандарт проектирования;
- стандарт оформления проектной документации;
- стандарт интерфейса пользователя.

_Стандарт проектирования_ должен определять:
- набор необходимых моделей (схем, диаграмм) на каждой стадии проектирования и степень их детализации;
- правила фиксации проектных решений на диаграммах, в том числе правила именования объектов и соглашения по терминологии, набор атрибутов для всех объектов и правила их заполнения на каждой стадии, правила оформления диаграмм, включая требования к форме и размерам объектов;
- требования к конфигурации рабочих мест разработчиков, включая настройки операционной системы и используемых CASE-средств;
- механизм обеспечения совместной работы над проектом, в том числе и правила интеграции подсистем проекта и анализа проектных решений на непротиворечивость.

_Стандарт оформления проектной документации_ должен регламентировать:
- комплектность, состав и структуру документации на каждой стадии;
- требования к ее содержанию и оформлению;
- правила подготовки, рассмотрения, согласования и утверждения документов.

_Стандарт интерфейса пользователя_ должен определять:
- правила оформления экранов (шрифты и цветовую палитру), состав и расположение окон и элементов управления;
- правила пользования клавиатурой и мышью;
- правила оформления текстов помощи;
- перечень стандартных сообщений;
- правила обработки реакции пользователя.

---
<div class="page-break" style="page-break-before: always;"></div>

## Планирование процесса проектирования, виды планов: календарный, индивидуальный, сетевой график разработки и проектирования программного обеспечения.

---
<div class="page-break" style="page-break-before: always;"></div>

## Структурный подход к проектированию программного обеспечения: основные принципы, лежащие в основе структурного подхода, средства описания функциональной структуры, средства описания отношения между данными, применение средств на стадиях жизненного цикла программного обеспечения.

---
<div class="page-break" style="page-break-before: always;"></div>

## Спецификации ПО при структурном подходе: формальные модели, зависящие от подхода к разработке и не зависящие от подхода – диаграммы переходов состояний, математические модели предметной области.

---
<div class="page-break" style="page-break-before: always;"></div>

## Метод функционального моделирования SADT: функциональная модель SADT, стандарт IDEFO; синтаксис и семантика моделей IDEFO: действия-функции; стрелки входа, управления, выхода, механизма исполнения; комбинированные стрелки, разбиение и соединение стрелок; туннели.

---
<div class="page-break" style="page-break-before: always;"></div>

## Построение моделей IDEFO: диаграммы, нумерация блоков и диаграмм, границы моделирования, наименование контекстного блока; типы связей между функциями: случайная, логическая, временная, процедурная, коммуникационная, последовательная, функциональная; дерево модели, презентационные диаграммы (FEO-диаграммы).

---
<div class="page-break" style="page-break-before: always;"></div>

## Метод описания процессов IDEF3: синтаксис и семантика моделей IDEF3: единица работы – действие (процесс); связи: временное предшествование, объектный поток, нечеткое отношение; соединения: «и», «или», «исключающее или»; синхронные и асинхронные соединения, парность соединений, комбинации соединений; указатели; декомпозиция действий.

---
<div class="page-break" style="page-break-before: always;"></div>

## Построение моделей IDEF3: диаграммы, нумерация блоков и диаграмм, сценарий, границы моделирования, определение действий и объектов.

---
<div class="page-break" style="page-break-before: always;"></div>

## Метод структурного анализа потоков данных: назначение диаграмм потоков данных (DFD); синтаксис и семантика DFD: функциональные блоки (системы и подсистемы, процессы), внешние сущности, потоки данных, хранилища данных, ветвление и объединение потоков данных.

---
<div class="page-break" style="page-break-before: always;"></div>

## Построение диаграмм потоков данных: нумерация объектов, построение контекстных диаграмм, правила детализации – балансировка, нумерация; спецификация процесса, требования, предъявляемые к спецификации, структурированный естественный язык описания спецификации процессов, верификация модели DFD – проверка на полноту и согласованность.

---
<div class="page-break" style="page-break-before: always;"></div>

## Структуры данных: несвязанные, с неявными связями, с явными связями; иерархические модели Джексона-Орра.

---
<div class="page-break" style="page-break-before: always;"></div>

## Моделирование данных – диаграммы «сущность-связь» (ERD): сущность, связь, атрибут.

---
<div class="page-break" style="page-break-before: always;"></div>

## Метод Баркера.

---
<div class="page-break" style="page-break-before: always;"></div>

## Метод IDEF1.

---
<div class="page-break" style="page-break-before: always;"></div>

## Структурная и функциональная схемы: структурные схемы пакетов программ, программного комплекса, программной системы; функциональная схема-схема данных, основные обозначения по ГОСТ 19.701-90.

---
<div class="page-break" style="page-break-before: always;"></div>

## Проектирование структуры программного обеспечения с использованием метода пошаговой детализации: основное правило и рекомендации по применению.

---
<div class="page-break" style="page-break-before: always;"></div>

## Структурные карты Константайна: назначение, типы вызов модулей-последовательный, параллельный, вызов сопрограммы; особые условия вызова-циклический, условный,  однократный; диаграммы реализации параллельного вызова и вызова сопрограммы; типы связи – по данным, по управлению.

---
<div class="page-break" style="page-break-before: always;"></div>

## Проектирование структур данных: представление  данных в оперативной памяти – векторная структура, списковые структуры; представление данных во внешней памяти – способы организации данных с последовательным и прямым доступом.

---
<div class="page-break" style="page-break-before: always;"></div>

## Проектирование программного обеспечения с использованием методов декомпозиции данных: метод Джексона, метод Варнье-Орра.

---
<div class="page-break" style="page-break-before: always;"></div>

## Структурный подход к проектированию программного обеспечения: основные достоинства и недостатки, особенности применения, перспективы развития.